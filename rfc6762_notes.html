<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<link href="rfc_notes.css" rel="stylesheet" type="text/css" />
<script src="rfc_notes.js"> </script>
<title>RFC 6762: Multicast DNS</title>
</head>
<body>
<h1>RFC 6762: Multicast DNS</h1><h2>Abstract</h2>

<div class="paragraph">
<span class="line" id="L17">   As networked devices become smaller, more portable, and more</span>
<span class="line" id="L18">   ubiquitous, the ability to operate with less configured</span>
<span class="line" id="L19">   infrastructure is increasingly important.  In particular, the ability</span>
<span class="line" id="L20">   to look up DNS resource record data types (including, but not limited</span>
<span class="line" id="L21">   to, host names) in the absence of a conventional managed DNS server</span>
<span class="line" id="L22">   is useful.</span>
</div>

<div class="paragraph">
<span class="line" id="L24">   Multicast DNS (mDNS) provides the ability to perform DNS-like</span>
<span class="line" id="L25">   operations on the local link in the absence of any conventional</span>
<span class="line" id="L26">   Unicast DNS server.  In addition, Multicast DNS designates a portion</span>
<span class="line" id="L27">   of the DNS namespace to be free for local use, without the need to</span>
<span class="line" id="L28">   pay any annual fee, and without the need to set up delegations or</span>
<span class="line" id="L29">   otherwise configure a conventional DNS server to answer for those</span>
<span class="line" id="L30">   names.</span>
</div>

<div class="paragraph">
<span class="line" id="L32">   The primary benefits of Multicast DNS names are that (i) they require</span>
<span class="line" id="L33">   little or no administration or configuration to set them up, (ii)</span>
<span class="line" id="L34">   they work when no infrastructure is present, and (iii) they work</span>
<span class="line" id="L35">   during infrastructure failures.</span>
</div>

<h2>Status of This Memo</h2>

<div class="paragraph">
<span class="line" id="L39">   This is an Internet Standards Track document.</span>
</div>

<div class="paragraph">
<span class="line" id="L41">   This document is a product of the Internet Engineering Task Force</span>
<span class="line" id="L42">   (IETF).  It represents the consensus of the IETF community.  It has</span>
<span class="line" id="L43">   received public review and has been approved for publication by the</span>
<span class="line" id="L44">   Internet Engineering Steering Group (IESG).  Further information on</span>
<span class="line" id="L45">   Internet Standards is available in Section 2 of RFC 5741.</span>
</div>

<div class="paragraph">
<span class="line" id="L47">   Information about the current status of this document, any errata,</span>
<span class="line" id="L48">   and how to provide feedback on it may be obtained at</span>
<span class="line" id="L49">   http://www.rfc-editor.org/info/rfc6762.</span>
</div>

<h2>Copyright Notice</h2>

<div class="paragraph">
<span class="line" id="L65">   Copyright (c) 2013 IETF Trust and the persons identified as the</span>
<span class="line" id="L66">   document authors.  All rights reserved.</span>
</div>

<div class="paragraph">
<span class="line" id="L68">   This document is subject to BCP 78 and the IETF Trust's Legal</span>
<span class="line" id="L69">   Provisions Relating to IETF Documents</span>
<span class="line" id="L70">   (http://trustee.ietf.org/license-info) in effect on the date of</span>
<span class="line" id="L71">   publication of this document.  Please review these documents</span>
<span class="line" id="L72">   carefully, as they describe your rights and restrictions with respect</span>
<span class="line" id="L73">   to this document.  Code Components extracted from this document must</span>
<span class="line" id="L74">   include Simplified BSD License text as described in Section 4.e of</span>
<span class="line" id="L75">   the Trust Legal Provisions and are provided without warranty as</span>
<span class="line" id="L76">   described in the Simplified BSD License.</span>
</div>

<div class="paragraph">
<span class="line" id="L78">   This document may contain material from IETF Documents or IETF</span>
<span class="line" id="L79">   Contributions published or made publicly available before November</span>
<span class="line" id="L80">   10, 2008.  The person(s) controlling the copyright in some of this</span>
<span class="line" id="L81">   material may not have granted the IETF Trust the right to allow</span>
<span class="line" id="L82">   modifications of such material outside the IETF Standards Process.</span>
<span class="line" id="L83">   Without obtaining an adequate license from the person(s) controlling</span>
<span class="line" id="L84">   the copyright in such materials, this document may not be modified</span>
<span class="line" id="L85">   outside the IETF Standards Process, and derivative works of it may</span>
<span class="line" id="L86">   not be created outside the IETF Standards Process, except to format</span>
<span class="line" id="L87">   it for publication as an RFC or to translate it into languages other</span>
<span class="line" id="L88">   than English.</span>
</div>

<h2>Table of Contents</h2>

<div class="paragraph">
<pre>   1. Introduction ....................................................4
   2. Conventions and Terminology Used in This Document ...............4
   3. Multicast DNS Names .............................................5
   4. Reverse Address Mapping .........................................7
   5. Querying ........................................................8
   6. Responding .....................................................13
   7. Traffic Reduction ..............................................22
   8. Probing and Announcing on Startup ..............................25
   9. Conflict Resolution ............................................31
   10. Resource Record TTL Values and Cache Coherency ................33
   11. Source Address Check ..........................................38
   12. Special Characteristics of Multicast DNS Domains ..............40
   13. Enabling and Disabling Multicast DNS ..........................41
   14. Considerations for Multiple Interfaces ........................42
   15. Considerations for Multiple Responders on the Same Machine ....43
   16. Multicast DNS Character Set ...................................45
   17. Multicast DNS Message Size ....................................46
   18. Multicast DNS Message Format ..................................47
   19. Summary of Differences between Multicast DNS and Unicast DNS ..51
   20. IPv6 Considerations ...........................................52
   21. Security Considerations .......................................52
   22. IANA Considerations ...........................................53
   23. Acknowledgments ...............................................56
   24. References ....................................................56
   Appendix A. Design Rationale for Choice of UDP Port Number ........60
   Appendix B. Design Rationale for Not Using Hashed Multicast
               Addresses .............................................61
   Appendix C. Design Rationale for Maximum Multicast DNS Name
               Length ................................................62
   Appendix D. Benefits of Multicast Responses .......................64
   Appendix E. Design Rationale for Encoding Negative Responses ......65
   Appendix F. Use of UTF-8 ..........................................66
   Appendix G. Private DNS Namespaces ................................67
   Appendix H. Deployment History ....................................67</pre></div>

<h2 id="s1">1 Introduction</h2>

<a name="s1" /><div class="paragraph" id="s1_p1">
<div class="clause" id="s1_p1_c1"><span class="label">s1_p1_c1</span>Multicast DNS and its companion technology DNS-Based Service Discovery [RFC6763] were created to provide IP networking with the ease-of-use and autoconfiguration for which AppleTalk was well-known [RFC6760].</div>
<div class="clause" id="s1_p1_c2"><span class="label">s1_p1_c2</span>When reading this document, familiarity with the concepts of Zero Configuration Networking [Zeroconf] and automatic link-local addressing [RFC3927] [RFC4862] is helpful.</div>
</div>

<div class="paragraph" id="s1_p2">
<div class="clause" id="s1_p2_c1"><span class="label">s1_p2_c1</span>Multicast DNS borrows heavily from the existing DNS protocol [RFC1034] [RFC1035] [RFC6195], using the existing DNS message structure, name syntax, and resource record types.</div>
<div class="clause" id="s1_p2_c2"><span class="label">s1_p2_c2</span>This document specifies no new operation codes or response codes.</div>
<div class="clause" id="s1_p2_c3"><span class="label">s1_p2_c3</span>This document describes how clients send DNS-like queries via IP multicast, and how a collection of hosts cooperate to collectively answer those queries in a useful manner.</div>
</div>

<h2 id="s2">2 Conventions and Terminology Used in This Document</h2>

<a name="s2" /><div class="paragraph" id="s2_p1">
<div class="clause" id="s2_p1_c1"><span class="label">s2_p1_c1</span>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in "Key words for use in RFCs to Indicate Requirement Levels" [RFC2119].</div>
</div>

<div class="paragraph" id="s2_p2">
<div class="clause" id="s2_p2_c1"><span class="label">s2_p2_c1</span>When this document uses the term "Multicast DNS", it should be taken to mean: "Clients performing DNS-like queries for DNS-like resource records by sending DNS-like UDP query and response messages over IP Multicast to UDP port 5353".</div>
<div class="clause" id="s2_p2_c2"><span class="label">s2_p2_c2</span>The design rationale for selecting UDP port 5353 is discussed in Appendix A.</div>
</div>

<div class="paragraph" id="s2_p3">
<div class="clause" id="s2_p3_c1"><span class="label">s2_p3_c1</span>This document uses the term "host name" in the strict sense to mean a fully qualified domain name that has an IPv4 or IPv6 address record.</div>
<div class="clause" id="s2_p3_c2"><span class="label">s2_p3_c2</span>It does not use the term "host name" in the commonly used but incorrect sense to mean just the first DNS label of a host's fully qualified domain name.</div>
</div>

<div class="paragraph" id="s2_p4">
<div class="clause" id="s2_p4_c1"><span class="label">s2_p4_c1</span>A DNS (or mDNS) packet contains an IP Time to Live (TTL) in the IP header, which is effectively a hop-count limit for the packet, to guard against routing loops.</div>
<div class="clause" id="s2_p4_c2"><span class="label">s2_p4_c2</span>Each resource record also contains a TTL, which is the number of seconds for which the resource record may be cached.</div>
<div class="clause" id="s2_p4_c3"><span class="label">s2_p4_c3</span>This document uses the term "IP TTL" to refer to the IP header TTL (hop limit), and the term "RR TTL" or just "TTL" to refer to the resource record TTL (cache lifetime).</div>
</div>

<div class="paragraph" id="s2_p5">
<div class="clause" id="s2_p5_c1"><span class="label">s2_p5_c1</span>DNS-format messages contain a header, a Question Section, then Answer, Authority, and Additional Record Sections.</div>
<div class="clause" id="s2_p5_c2"><span class="label">s2_p5_c2</span>The Answer, Authority, and Additional Record Sections all hold resource records in the same format.</div>
<div class="clause" id="s2_p5_c3"><span class="label">s2_p5_c3</span>Where this document describes issues that apply equally to all three sections, it uses the term "Resource Record Sections" to refer collectively to these three sections.</div>
</div>

<div class="paragraph" id="s2_p6">
<div class="clause" id="s2_p6_c1"><span class="label">s2_p6_c1</span>This document uses the terms "shared" and "unique" when referring to resource record sets [RFC1034]:</div>
</div>

<div class="paragraph" id="s2_p7">
<div class="clause" id="s2_p7_c1"><span class="label">s2_p7_c1</span>A "shared" resource record set is one where several Multicast DNS responders may have records with the same name, rrtype, and rrclass, and several responders may respond to a particular query.</div>
</div>

<div class="paragraph" id="s2_p8">
<div class="clause" id="s2_p8_c1"><span class="label">s2_p8_c1</span>A "unique" resource record set is one where all the records with that name, rrtype, and rrclass are conceptually under the control or ownership of a single responder, and it is expected that at most one responder should respond to a query for that name, rrtype, and rrclass.</div>
<div class="clause must" id="s2_p8_c2"><span class="label">s2_p8_c2</span>Before claiming ownership of a unique resource record set, a responder MUST probe to verify that no other responder already claims ownership of that set, as described in Section 8.1, "Probing".</div>
<div class="notes" onmouseout="removeClass(document.getElementById('s2_p8_c2'), 'hover')" onmouseover="addClass(document.getElementById('s2_p8_c2'), 'hover')">
<div class="ref">See <a href="#s8.1">s8.1</a></div>
</div>

<div class="clause must" id="s2_p8_c3"><span class="label">s2_p8_c3</span>(For fault-tolerance and other reasons, sometimes it is permissible to have more than one responder answering for a particular "unique" resource record set, but such cooperating responders MUST give answers containing identical rdata for these records.</div>
<div class="clause" id="s2_p8_c4"><span class="label">s2_p8_c4</span>If they do not give answers containing identical rdata, then the probing step will reject the data as being inconsistent with what is already being advertised on the network for those names.)</div>
</div>

<div class="paragraph" id="s2_p9">
<div class="clause" id="s2_p9_c1"><span class="label">s2_p9_c1</span>Strictly speaking, the terms "shared" and "unique" apply to resource record sets, not to individual resource records.</div>
<div class="clause" id="s2_p9_c2"><span class="label">s2_p9_c2</span>However, it is sometimes convenient to talk of "shared resource records" and "unique resource records".</div>
<div class="clause" id="s2_p9_c3"><span class="label">s2_p9_c3</span>When used this way, the terms should be understood to mean a record that is a member of a "shared" or "unique" resource record set, respectively.</div>
</div>

<h2 id="s3">3 Multicast DNS Names</h2>

<a name="s3" /><div class="paragraph" id="s3_p1">
<div class="clause" id="s3_p1_c1"><span class="label">s3_p1_c1</span>A host that belongs to an organization or individual who has control over some portion of the DNS namespace can be assigned a globally unique name within that portion of the DNS namespace, such as, "cheshire.example.com.".</div>
<div class="clause" id="s3_p1_c2"><span class="label">s3_p1_c2</span>For those of us who have this luxury, this works very well.</div>
<div class="clause" id="s3_p1_c3"><span class="label">s3_p1_c3</span>However, the majority of home computer users do not have easy access to any portion of the global DNS namespace within which they have the authority to create names.</div>
<div class="clause" id="s3_p1_c4"><span class="label">s3_p1_c4</span>This leaves the majority of home computers effectively anonymous for practical purposes.</div>
</div>

<div class="paragraph" id="s3_p2">
<div class="clause" id="s3_p2_c1"><span class="label">s3_p2_c1</span>To remedy this problem, this document allows any computer user to elect to give their computers link-local Multicast DNS host names of the form: "single-dns-label.local.".</div>
<div class="clause" id="s3_p2_c2"><span class="label">s3_p2_c2</span>For example, a laptop computer may answer to the name "MyComputer.local.".</div>
<div class="clause" id="s3_p2_c3"><span class="label">s3_p2_c3</span>Any computer user is granted the authority to name their computer this way, provided that the chosen host name is not already in use on that link.</div>
<div class="clause" id="s3_p2_c4"><span class="label">s3_p2_c4</span>Having named their computer this way, the user has the authority to continue utilizing that name until such time as a name conflict occurs on the link that is not resolved in the user's favor.</div>
<div class="clause must" id="s3_p2_c5"><span class="label">s3_p2_c5</span>If this happens, the computer (or its human user) MUST cease using the name, and SHOULD attempt to allocate a new unique name for use on that link.</div>
<div class="clause" id="s3_p2_c6"><span class="label">s3_p2_c6</span>These conflicts are expected to be relatively rare for people who choose reasonably imaginative names, but it is still important to have a mechanism in place to handle them when they happen.</div>
</div>

<div class="paragraph" id="s3_p3">
<div class="clause" id="s3_p3_c1"><span class="label">s3_p3_c1</span>This document specifies that the DNS top-level domain ".local." is a special domain with special semantics, namely that any fully qualified name ending in ".local." is link-local, and names within this domain are meaningful only on the link where they originate.</div>
<div class="clause" id="s3_p3_c2"><span class="label">s3_p3_c2</span>This is analogous to IPv4 addresses in the 169.254/16 prefix or IPv6 addresses in the FE80::/10 prefix, which are link-local and meaningful only on the link where they originate.</div>
</div>

<div class="paragraph" id="s3_p4">
<div class="clause must" id="s3_p4_c1"><span class="label">s3_p4_c1</span>Any DNS query for a name ending with ".local." MUST be sent to the mDNS IPv4 link-local multicast address 224.0.0.251 (or its IPv6 equivalent FF02::FB).</div>
<div class="clause" id="s3_p4_c2"><span class="label">s3_p4_c2</span>The design rationale for using a fixed multicast address instead of selecting from a range of multicast addresses using a hash function is discussed in Appendix B.</div>
<div class="clause may" id="s3_p4_c3"><span class="label">s3_p4_c3</span>Implementers MAY choose to look up such names concurrently via other mechanisms (e.g., Unicast DNS) and coalesce the results in some fashion.</div>
<div class="clause" id="s3_p4_c4"><span class="label">s3_p4_c4</span>Implementers choosing to do this should be aware of the potential for user confusion when a given name can produce different results depending on external network conditions (such as, but not limited to, which name lookup mechanism responds faster).</div>
</div>

<div class="paragraph" id="s3_p5">
<div class="clause" id="s3_p5_c1"><span class="label">s3_p5_c1</span>It is unimportant whether a name ending with ".local." occurred because the user explicitly typed in a fully qualified domain name ending in ".local.", or because the user entered an unqualified domain name and the host software appended the suffix ".local." because that suffix appears in the user's search list.</div>
<div class="clause" id="s3_p5_c2"><span class="label">s3_p5_c2</span>The ".local." suffix could appear in the search list because the user manually configured it, or because it was received via DHCP [RFC2132] or via any other mechanism for configuring the DNS search list.</div>
<div class="clause" id="s3_p5_c3"><span class="label">s3_p5_c3</span>In this respect the ".local." suffix is treated no differently from any other search domain that might appear in the DNS search list.</div>
</div>

<div class="paragraph" id="s3_p6">
<div class="clause may" id="s3_p6_c1"><span class="label">s3_p6_c1</span>DNS queries for names that do not end with ".local." MAY be sent to the mDNS multicast address, if no other conventional DNS server is available.</div>
<div class="clause" id="s3_p6_c2"><span class="label">s3_p6_c2</span>This can allow hosts on the same link to continue communicating using each other's globally unique DNS names during network outages that disrupt communication with the greater Internet.</div>
<div class="clause" id="s3_p6_c3"><span class="label">s3_p6_c3</span>When resolving global names via local multicast, it is even more important to use DNS Security Extensions (DNSSEC) [RFC4033] or other security mechanisms to ensure that the response is trustworthy.</div>
<div class="clause" id="s3_p6_c4"><span class="label">s3_p6_c4</span>Resolving global names via local multicast is a contentious issue, and this document does not discuss it further, instead concentrating on the issue of resolving local names using DNS messages sent to a multicast address.</div>
</div>

<div class="paragraph" id="s3_p7">
<div class="clause" id="s3_p7_c1"><span class="label">s3_p7_c1</span>This document recommends a single flat namespace for dot-local host names, (i.e., the names of DNS "A" and "AAAA" records, which map names to IPv4 and IPv6 addresses), but other DNS record types (such as those used by DNS-Based Service Discovery [RFC6763]) may contain as many labels as appropriate for the desired usage, up to a maximum of 255 bytes, plus a terminating zero byte at the end.</div>
<div class="clause" id="s3_p7_c2"><span class="label">s3_p7_c2</span>Name length issues are discussed further in Appendix C.</div>
</div>

<div class="paragraph" id="s3_p8">
<div class="clause" id="s3_p8_c1"><span class="label">s3_p8_c1</span>Enforcing uniqueness of host names is probably desirable in the common case, but this document does not mandate that.</div>
<div class="clause" id="s3_p8_c2"><span class="label">s3_p8_c2</span>It is permissible for a collection of coordinated hosts to agree to maintain multiple DNS address records with the same name, possibly for load-balancing or fault-tolerance reasons.</div>
<div class="clause" id="s3_p8_c3"><span class="label">s3_p8_c3</span>This document does not take a position on whether that is sensible.</div>
<div class="clause" id="s3_p8_c4"><span class="label">s3_p8_c4</span>It is important that both modes of operation be supported.</div>
<div class="clause" id="s3_p8_c5"><span class="label">s3_p8_c5</span>The Multicast DNS protocol allows hosts to verify and maintain unique names for resource records where that behavior is desired, and it also allows hosts to maintain multiple resource records with a single shared name where that behavior is desired.</div>
<div class="clause" id="s3_p8_c6"><span class="label">s3_p8_c6</span>This consideration applies to all resource records, not just address records (host names).</div>
<div class="clause" id="s3_p8_c7"><span class="label">s3_p8_c7</span>In summary: It is required that the protocol have the ability to detect and handle name conflicts, but it is not required that this ability be used for every record.</div>
</div>

<h2 id="s4">4 Reverse Address Mapping</h2>

<a name="s4" /><div class="paragraph" id="s4_p1">
<div class="clause" id="s4_p1_c1"><span class="label">s4_p1_c1</span>Like ".local.", the IPv4 and IPv6 reverse mapping domains are also defined to be link-local:</div>
</div>

<div class="paragraph" id="s4_p2">
<div class="clause must" id="s4_p2_c1"><span class="label">s4_p2_c1</span>Any DNS query for a name ending with "254.169.in-addr.arpa." MUST be sent to the mDNS IPv4 link-local multicast address 224.0.0.251 or the mDNS IPv6 multicast address FF02::FB.</div>
<div class="clause" id="s4_p2_c2"><span class="label">s4_p2_c2</span>Since names under this domain correspond to IPv4 link-local addresses, it is logical that the local link is the best place to find information pertaining to those names.</div>
</div>

<div class="paragraph" id="s4_p3">
<div class="clause must" id="s4_p3_c1"><span class="label">s4_p3_c1</span>Likewise, any DNS query for a name within the reverse mapping domains for IPv6 link-local addresses ("8.e.f.ip6.arpa.", "9.e.f.ip6.arpa.", "a.e.f.ip6.arpa.", and "b.e.f.ip6.arpa.") MUST be sent to the mDNS IPv6 link-local multicast address FF02::FB or the mDNS IPv4 link-local multicast address 224.0.0.251.</div>
</div>

<h2 id="s5">5 Querying</h2>

<a name="s5" /><div class="paragraph" id="s5_p1">
<div class="clause" id="s5_p1_c1"><span class="label">s5_p1_c1</span>There are two kinds of Multicast DNS queries: one-shot queries of the kind made by legacy DNS resolvers, and continuous, ongoing Multicast DNS queries made by fully compliant Multicast DNS queriers, which support asynchronous operations including DNS-Based Service Discovery [RFC6763].</div>
</div>

<div class="paragraph" id="s5_p2">
<div class="clause must" id="s5_p2_c1"><span class="label">s5_p2_c1</span>Except in the rare case of a Multicast DNS responder that is advertising only shared resource records and no unique records, a Multicast DNS responder MUST also implement a Multicast DNS querier so that it can first verify the uniqueness of those records before it begins answering queries for them.</div>
</div>

<h2 id="s5.1">5.1 One-Shot Multicast DNS Queries</h2>

<a name="s5.1" /><div class="paragraph" id="s5.1_p1">
<div class="clause" id="s5.1_p1_c1"><span class="label">s5.1_p1_c1</span>The most basic kind of Multicast DNS client may simply send standard DNS queries blindly to 224.0.0.251:5353, without necessarily even being aware of what a multicast address is.</div>
<div class="clause" id="s5.1_p1_c2"><span class="label">s5.1_p1_c2</span>This change can typically be implemented with just a few lines of code in an existing DNS resolver library.</div>
<div class="clause" id="s5.1_p1_c3"><span class="label">s5.1_p1_c3</span>If a name being queried falls within one of the reserved Multicast DNS domains (see Sections 3 and 4), then, rather than using the configured Unicast DNS server address, the query is instead sent to 224.0.0.251:5353 (or its IPv6 equivalent [FF02::FB]:5353).</div>
<div class="clause" id="s5.1_p1_c4"><span class="label">s5.1_p1_c4</span>Typically, the timeout would also be shortened to two or three seconds.</div>
<div class="clause" id="s5.1_p1_c5"><span class="label">s5.1_p1_c5</span>It's possible to make a minimal Multicast DNS resolver with only these simple changes.</div>
<div class="clause must" id="s5.1_p1_c6"><span class="label">s5.1_p1_c6</span>These queries are typically done using a high-numbered ephemeral UDP source port, but regardless of whether they are sent from a dynamic port or from a fixed port, these queries MUST NOT be sent using UDP source port 5353, since using UDP source port 5353 signals the presence of a fully compliant Multicast DNS querier, as described below.</div>
</div>

<div class="paragraph" id="s5.1_p2">
<div class="clause" id="s5.1_p2_c1"><span class="label">s5.1_p2_c1</span>A simple DNS resolver like this will typically just take the first response it receives.</div>
<div class="clause" id="s5.1_p2_c2"><span class="label">s5.1_p2_c2</span>It will not listen for additional UDP responses, but in many instances this may not be a serious problem.</div>
<div class="clause" id="s5.1_p2_c3"><span class="label">s5.1_p2_c3</span>If a user types "http://MyPrinter.local." into their web browser, and their simple DNS resolver just takes the first response it receives, and the user gets to see the status and configuration web page for their printer, then the protocol has met the user's needs in this case.</div>
</div>

<div class="paragraph" id="s5.1_p3">
<div class="clause" id="s5.1_p3_c1"><span class="label">s5.1_p3_c1</span>While a basic DNS resolver like this may be adequate for simple host name lookup, it may not get ideal behavior in other cases.</div>
<div class="clause" id="s5.1_p3_c2"><span class="label">s5.1_p3_c2</span>Additional refinements to create a fully compliant Multicast DNS querier are described below.</div>
</div>

<h2 id="s5.2">5.2 Continuous Multicast DNS Querying</h2>

<a name="s5.2" /><div class="paragraph" id="s5.2_p1">
<div class="clause" id="s5.2_p1_c1"><span class="label">s5.2_p1_c1</span>In one-shot queries, the underlying assumption is that the transaction begins when the application issues a query, and ends when the first response is received.</div>
<div class="clause" id="s5.2_p1_c2"><span class="label">s5.2_p1_c2</span>There is another type of query operation that is more asynchronous, in which having received one response is not necessarily an indication that there will be no more relevant responses, and the querying operation continues until no further responses are required.</div>
<div class="clause" id="s5.2_p1_c3"><span class="label">s5.2_p1_c3</span>Determining when no further responses are required depends on the type of operation being performed.</div>
<div class="clause" id="s5.2_p1_c4"><span class="label">s5.2_p1_c4</span>If the operation is looking up the IPv4 and IPv6 addresses of another host, then no further responses are required once a successful connection has been made to one of those IPv4 or IPv6 addresses.</div>
<div class="clause" id="s5.2_p1_c5"><span class="label">s5.2_p1_c5</span>If the operation is browsing to present the user with a list of DNS-SD services found on the network [RFC6763], then no further responses are required once the user indicates this to the user-interface software, e.g., by closing the network browsing window that was displaying the list of discovered services.</div>
</div>

<div class="paragraph" id="s5.2_p2">
<div class="clause" id="s5.2_p2_c1"><span class="label">s5.2_p2_c1</span>Imagine some hypothetical software that allows users to discover network printers.</div>
<div class="clause" id="s5.2_p2_c2"><span class="label">s5.2_p2_c2</span>The user wishes to discover all printers on the local network, not only the printer that is quickest to respond.</div>
<div class="clause" id="s5.2_p2_c3"><span class="label">s5.2_p2_c3</span>When the user is actively looking for a network printer to use, they open a network browsing window that displays the list of discovered printers.</div>
<div class="clause" id="s5.2_p2_c4"><span class="label">s5.2_p2_c4</span>It would be convenient for the user if they could rely on this list of network printers to stay up to date as network printers come and go, rather than displaying out-of-date stale information, and requiring the user explicitly to click a "refresh" button any time they want to see accurate information (which, from the moment it is displayed, is itself already beginning to become out-of-date and stale).</div>
<div class="clause" id="s5.2_p2_c5"><span class="label">s5.2_p2_c5</span>If we are to display a continuously updated live list like this, we need to be able to do it efficiently, without naive constant polling, which would be an unreasonable burden on the network.</div>
<div class="clause" id="s5.2_p2_c6"><span class="label">s5.2_p2_c6</span>It is not expected that all users will be browsing to discover new printers all the time, but when a user is browsing to discover service instances for an extended period, we want to be able to support that operation efficiently.</div>
</div>

<div class="paragraph" id="s5.2_p3">
<div class="clause must" id="s5.2_p3_c1"><span class="label">s5.2_p3_c1</span>Therefore, when retransmitting Multicast DNS queries to implement this kind of continuous monitoring, the interval between the first two queries MUST be at least one second, the intervals between successive queries MUST increase by at least a factor of two, and the querier MUST implement Known-Answer Suppression, as described below in Section 7.1.</div>
<div class="clause" id="s5.2_p3_c2"><span class="label">s5.2_p3_c2</span>The Known-Answer Suppression mechanism tells responders which answers are already known to the querier, thereby allowing responders to avoid wasting network capacity with pointless repeated transmission of those answers.</div>
<div class="clause" id="s5.2_p3_c3"><span class="label">s5.2_p3_c3</span>A querier retransmits its question because it wishes to receive answers it may have missed the first time, not because it wants additional duplicate copies of answers it already received.</div>
<div class="clause" id="s5.2_p3_c4"><span class="label">s5.2_p3_c4</span>Failure to implement Known-Answer Suppression can result in unacceptable levels of network traffic.</div>
<div class="clause may" id="s5.2_p3_c5"><span class="label">s5.2_p3_c5</span>When the interval between queries reaches or exceeds 60 minutes, a querier MAY cap the interval to a maximum of 60 minutes, and perform subsequent queries at a steady-state rate of one query per hour.</div>
<div class="clause should" id="s5.2_p3_c6"><span class="label">s5.2_p3_c6</span>To avoid accidental synchronization when, for some reason, multiple clients begin querying at exactly the same moment (e.g., because of some common external trigger event), a Multicast DNS querier SHOULD also delay the first query of the series by a randomly chosen amount in the range 20-120 ms.</div>
</div>

<div class="paragraph" id="s5.2_p4">
<div class="clause" id="s5.2_p4_c1"><span class="label">s5.2_p4_c1</span>When a Multicast DNS querier receives an answer, the answer contains a TTL value that indicates for how many seconds this answer is valid.</div>
<div class="clause should" id="s5.2_p4_c2"><span class="label">s5.2_p4_c2</span>After this interval has passed, the answer will no longer be valid and SHOULD be deleted from the cache.</div>
<div class="clause should" id="s5.2_p4_c3"><span class="label">s5.2_p4_c3</span>Before the record expiry time is reached, a Multicast DNS querier that has local clients with an active interest in the state of that record (e.g., a network browsing window displaying a list of discovered services to the user) SHOULD reissue its query to determine whether the record is still valid.</div>
</div>

<div class="paragraph" id="s5.2_p5">
<div class="clause" id="s5.2_p5_c1"><span class="label">s5.2_p5_c1</span>To perform this cache maintenance, a Multicast DNS querier should plan to retransmit its query after at least 50% of the record lifetime has elapsed.</div>
<div class="clause" id="s5.2_p5_c2"><span class="label">s5.2_p5_c2</span>This document recommends the following specific strategy.</div>
</div>

<div class="paragraph" id="s5.2_p6">
<div class="clause" id="s5.2_p6_c1"><span class="label">s5.2_p6_c1</span>The querier should plan to issue a query at 80% of the record lifetime, and then if no answer is received, at 85%, 90%, and 95%.</div>
<div class="clause" id="s5.2_p6_c2"><span class="label">s5.2_p6_c2</span>If an answer is received, then the remaining TTL is reset to the value given in the answer, and this process repeats for as long as the Multicast DNS querier has an ongoing interest in the record.</div>
<div class="clause" id="s5.2_p6_c3"><span class="label">s5.2_p6_c3</span>If no answer is received after four queries, the record is deleted when it reaches 100% of its lifetime.</div>
<div class="clause must" id="s5.2_p6_c4"><span class="label">s5.2_p6_c4</span>A Multicast DNS querier MUST NOT perform this cache maintenance for records for which it has no local clients with an active interest.</div>
<div class="clause" id="s5.2_p6_c5"><span class="label">s5.2_p6_c5</span>If the expiry of a particular record from the cache would result in no net effect to any client software running on the querier device, and no visible effect to the human user, then there is no reason for the Multicast DNS querier to waste network capacity checking whether the record remains valid.</div>
</div>

<div class="paragraph" id="s5.2_p7">
<div class="clause" id="s5.2_p7_c1"><span class="label">s5.2_p7_c1</span>To avoid the case where multiple Multicast DNS queriers on a network all issue their queries simultaneously, a random variation of 2% of the record TTL should be added, so that queries are scheduled to be performed at 80-82%, 85-87%, 90-92%, and then 95-97% of the TTL.</div>
</div>

<div class="paragraph" id="s5.2_p8">
<div class="clause should" id="s5.2_p8_c1"><span class="label">s5.2_p8_c1</span>An additional efficiency optimization SHOULD be performed when a Multicast DNS response is received containing a unique answer (as indicated by the cache-flush bit being set, described in Section 10.2, "Announcements to Flush Outdated Cache Entries").</div>
<div class="clause" id="s5.2_p8_c2"><span class="label">s5.2_p8_c2</span>In this case, there is no need for the querier to continue issuing a stream of queries with exponentially increasing intervals, since the receipt of a unique answer is a good indication that no other answers will be forthcoming.</div>
<div class="clause should" id="s5.2_p8_c3"><span class="label">s5.2_p8_c3</span>In this case, the Multicast DNS querier SHOULD plan to issue its next query for this record at 80-82% of the record's TTL, as described above.</div>
</div>

<div class="paragraph" id="s5.2_p9">
<div class="clause must" id="s5.2_p9_c1"><span class="label">s5.2_p9_c1</span>A compliant Multicast DNS querier, which implements the rules specified in this document, MUST send its Multicast DNS queries from UDP source port 5353 (the well-known port assigned to mDNS), and MUST listen for Multicast DNS replies sent to UDP destination port 5353 at the mDNS link-local multicast address (224.0.0.251 and/or its IPv6 equivalent FF02::FB).</div>
</div>

<h2 id="s5.3">5.3 Multiple Questions per Query</h2>

<a name="s5.3" /><div class="paragraph" id="s5.3_p1">
<div class="clause" id="s5.3_p1_c1"><span class="label">s5.3_p1_c1</span>Multicast DNS allows a querier to place multiple questions in the Question Section of a single Multicast DNS query message.</div>
</div>

<div class="paragraph" id="s5.3_p2">
<div class="clause" id="s5.3_p2_c1"><span class="label">s5.3_p2_c1</span>The semantics of a Multicast DNS query message containing multiple questions is identical to a series of individual DNS query messages containing one question each.</div>
<div class="clause" id="s5.3_p2_c2"><span class="label">s5.3_p2_c2</span>Combining multiple questions into a single message is purely an efficiency optimization and has no other semantic significance.</div>
</div>

<h2 id="s5.4">5.4 Questions Requesting Unicast Responses</h2>

<a name="s5.4" /><div class="paragraph" id="s5.4_p1">
<div class="clause" id="s5.4_p1_c1"><span class="label">s5.4_p1_c1</span>Sending Multicast DNS responses via multicast has the benefit that all the other hosts on the network get to see those responses, enabling them to keep their caches up to date and detect conflicting responses.</div>
</div>

<div class="paragraph" id="s5.4_p2">
<div class="clause" id="s5.4_p2_c1"><span class="label">s5.4_p2_c1</span>However, there are situations where all the other hosts on the network don't need to see every response.</div>
<div class="clause" id="s5.4_p2_c2"><span class="label">s5.4_p2_c2</span>Some examples are a laptop computer waking from sleep, the Ethernet cable being connected to a running machine, or a previously inactive interface being activated through a configuration change.</div>
<div class="clause" id="s5.4_p2_c3"><span class="label">s5.4_p2_c3</span>At the instant of wake-up or link activation, the machine is a brand new participant on a new network.</div>
<div class="clause" id="s5.4_p2_c4"><span class="label">s5.4_p2_c4</span>Its Multicast DNS cache for that interface is empty, and it has no knowledge of its peers on that link.</div>
<div class="clause" id="s5.4_p2_c5"><span class="label">s5.4_p2_c5</span>It may have a significant number of questions that it wants answered right away, to discover information about its new surroundings and present that information to the user.</div>
<div class="clause" id="s5.4_p2_c6"><span class="label">s5.4_p2_c6</span>As a new participant on the network, it has no idea whether the exact same questions may have been asked and answered just seconds ago.</div>
<div class="clause" id="s5.4_p2_c7"><span class="label">s5.4_p2_c7</span>In this case, triggering a large sudden flood of multicast responses may impose an unreasonable burden on the network.</div>
</div>

<div class="paragraph" id="s5.4_p3">
<div class="clause" id="s5.4_p3_c1"><span class="label">s5.4_p3_c1</span>To avoid large floods of potentially unnecessary responses in these cases, Multicast DNS defines the top bit in the class field of a DNS question as the unicast-response bit.</div>
<div class="clause" id="s5.4_p3_c2"><span class="label">s5.4_p3_c2</span>When this bit is set in a question, it indicates that the querier is willing to accept unicast replies in response to this specific query, as well as the usual multicast responses.</div>
<div class="clause" id="s5.4_p3_c3"><span class="label">s5.4_p3_c3</span>These questions requesting unicast responses are referred to as "QU" questions, to distinguish them from the more usual questions requesting multicast responses ("QM" questions).</div>
<div class="clause should" id="s5.4_p3_c4"><span class="label">s5.4_p3_c4</span>A Multicast DNS querier sending its initial batch of questions immediately on wake from sleep or interface activation SHOULD set the unicast-response bit in those questions.</div>
</div>

<div class="paragraph" id="s5.4_p4">
<div class="clause should" id="s5.4_p4_c1"><span class="label">s5.4_p4_c1</span>When a question is retransmitted (as described in Section 5.2), the unicast-response bit SHOULD NOT be set in subsequent retransmissions of that question.</div>
<div class="clause should" id="s5.4_p4_c2"><span class="label">s5.4_p4_c2</span>Subsequent retransmissions SHOULD be usual "QM" questions.</div>
<div class="clause" id="s5.4_p4_c3"><span class="label">s5.4_p4_c3</span>After the first question has received its responses, the querier should have a large Known-Answer list (Section 7.1) so that subsequent queries should elicit few, if any, further responses.</div>
<div class="clause" id="s5.4_p4_c4"><span class="label">s5.4_p4_c4</span>Reverting to multicast responses as soon as possible is important because of the benefits that multicast responses provide (see Appendix D).</div>
<div class="clause should" id="s5.4_p4_c5"><span class="label">s5.4_p4_c5</span>In addition, the unicast-response bit SHOULD be set only for questions that are active and ready to be sent the moment of wake from sleep or interface activation.</div>
<div class="clause should" id="s5.4_p4_c6"><span class="label">s5.4_p4_c6</span>New questions created by local clients afterwards should be treated as normal "QM" questions and SHOULD NOT have the unicast-response bit set on the first question of the series.</div>
</div>

<div class="paragraph" id="s5.4_p5">
<div class="clause should" id="s5.4_p5_c1"><span class="label">s5.4_p5_c1</span>When receiving a question with the unicast-response bit set, a responder SHOULD usually respond with a unicast packet directed back to the querier.</div>
<div class="clause should" id="s5.4_p5_c2"><span class="label">s5.4_p5_c2</span>However, if the responder has not multicast that record recently (within one quarter of its TTL), then the responder SHOULD instead multicast the response so as to keep all the peer caches up to date, and to permit passive conflict detection.</div>
<div class="clause" id="s5.4_p5_c3"><span class="label">s5.4_p5_c3</span>In the case of answering a probe question (Section 8.1) with the unicast- response bit set, the responder should always generate the requested unicast response, but it may also send a multicast announcement if the time since the last multicast announcement of that record is more than a quarter of its TTL.</div>
</div>

<div class="paragraph" id="s5.4_p6">
<div class="clause" id="s5.4_p6_c1"><span class="label">s5.4_p6_c1</span>Unicast replies are subject to all the same packet generation rules as multicast replies, including the cache-flush bit (Section 10.2) and (except when defending a unique name against a probe from another host) randomized delays to reduce network collisions (Section 6).</div>
</div>

<h2 id="s5.5">5.5 Direct Unicast Queries to Port 5353</h2>

<a name="s5.5" /><div class="paragraph" id="s5.5_p1">
<div class="clause" id="s5.5_p1_c1"><span class="label">s5.5_p1_c1</span>In specialized applications there may be rare situations where it makes sense for a Multicast DNS querier to send its query via unicast to a specific machine.</div>
<div class="clause should" id="s5.5_p1_c2"><span class="label">s5.5_p1_c2</span>When a Multicast DNS responder receives a query via direct unicast, it SHOULD respond as it would for "QU" questions, as described above in Section 5.4.</div>
<div class="clause should" id="s5.5_p1_c3"><span class="label">s5.5_p1_c3</span>Since it is possible for a unicast query to be received from a machine outside the local link, responders SHOULD check that the source address in the query packet matches the local subnet for that link (or, in the case of IPv6, the source address has an on-link prefix) and silently ignore the packet if not.</div>
</div>

<div class="paragraph" id="s5.5_p2">
<div class="clause" id="s5.5_p2_c1"><span class="label">s5.5_p2_c1</span>There may be specialized situations, outside the scope of this document, where it is intended and desirable to create a responder that does answer queries originating outside the local link.</div>
<div class="clause" id="s5.5_p2_c2"><span class="label">s5.5_p2_c2</span>Such a responder would need to ensure that these non-local queries are always answered via unicast back to the querier, since an answer sent via link-local multicast would not reach a querier outside the local link.</div>
</div>

<h2 id="s6">6 Responding</h2>

<a name="s6" /><div class="paragraph" id="s6_p1">
<div class="clause" id="s6_p1_c1"><span class="label">s6_p1_c1</span>When a Multicast DNS responder constructs and sends a Multicast DNS response message, the Resource Record Sections of that message must contain only records for which that responder is explicitly authoritative.</div>
<div class="clause" id="s6_p1_c2"><span class="label">s6_p1_c2</span>These answers may be generated because the record answers a question received in a Multicast DNS query message, or at certain other times that the responder determines than an unsolicited announcement is warranted.</div>
<div class="clause must" id="s6_p1_c3"><span class="label">s6_p1_c3</span>A Multicast DNS responder MUST NOT place records from its cache, which have been learned from other responders on the network, in the Resource Record Sections of outgoing response messages.</div>
<div class="clause" id="s6_p1_c4"><span class="label">s6_p1_c4</span>Only an authoritative source for a given record is allowed to issue responses containing that record.</div>
</div>

<div class="paragraph" id="s6_p2">
<div class="clause" id="s6_p2_c1"><span class="label">s6_p2_c1</span>The determination of whether a given record answers a given question is made using the standard DNS rules: the record name must match the question name, the record rrtype must match the question qtype unless the qtype is "ANY" (255) or the rrtype is "CNAME" (5), and the record rrclass must match the question qclass unless the qclass is "ANY" (255).</div>
<div class="clause must" id="s6_p2_c2"><span class="label">s6_p2_c2</span>As with Unicast DNS, generally only DNS class 1 ("Internet") is used, but should client software use classes other than 1, the matching rules described above MUST be used.</div>
</div>

<div class="paragraph" id="s6_p3">
<div class="clause must" id="s6_p3_c1"><span class="label">s6_p3_c1</span>A Multicast DNS responder MUST only respond when it has a positive, non-null response to send, or it authoritatively knows that a particular record does not exist.</div>
<div class="clause must" id="s6_p3_c2"><span class="label">s6_p3_c2</span>For unique records, where the host has already established sole ownership of the name, it MUST return negative answers to queries for records that it knows not to exist.</div>
<div class="clause must" id="s6_p3_c3"><span class="label">s6_p3_c3</span>For example, a host with no IPv6 address, that has claimed sole ownership of the name "host.local." for all rrtypes, MUST respond to AAAA queries for "host.local." by sending a negative answer indicating that no AAAA records exist for that name.</div>
<div class="clause" id="s6_p3_c4"><span class="label">s6_p3_c4</span>See Section 6.1, "Negative Responses".</div>
<div class="clause" id="s6_p3_c5"><span class="label">s6_p3_c5</span>For shared records, which are owned by no single host, the nonexistence of a given record is ascertained by the failure of any machine to respond to the Multicast DNS query, not by any explicit negative response.</div>
<div class="clause must" id="s6_p3_c6"><span class="label">s6_p3_c6</span>For shared records, NXDOMAIN and other error responses MUST NOT be sent.</div>
</div>

<div class="paragraph" id="s6_p4">
<div class="clause must" id="s6_p4_c1"><span class="label">s6_p4_c1</span>Multicast DNS responses MUST NOT contain any questions in the Question Section.</div>
<div class="notes" onmouseout="removeClass(document.getElementById('s6_p4_c1'), 'hover')" onmouseover="addClass(document.getElementById('s6_p4_c1'), 'hover')">
<div class="coderef">impl: <a href="https://github.com/infidel/ocaml-dns/blob/master/lib/query.ml#l55">https://github.com/infidel/ocaml-dns/blob/master/lib/query.ml#l55</a></div>
<div class="coderef">test: <a href="https://github.com/infidel/ocaml-dns/blob/master/lib_test/ounit/test_query.ml#l137">https://github.com/infidel/ocaml-dns/blob/master/lib_test/ounit/test_query.ml#l137</a></div>
<div class="coderef">test: <a href="https://github.com/infidel/ocaml-dns/blob/master/lib_test/ounit/test_mdns_responder.ml#l73">https://github.com/infidel/ocaml-dns/blob/master/lib_test/ounit/test_mdns_responder.ml#l73</a></div>
</div>

<div class="clause must" id="s6_p4_c2"><span class="label">s6_p4_c2</span>Any questions in the Question Section of a received Multicast DNS response MUST be silently ignored.</div>
<div class="notes" onmouseout="removeClass(document.getElementById('s6_p4_c2'), 'hover')" onmouseover="addClass(document.getElementById('s6_p4_c2'), 'hover')">
<div class="coderef">impl: <a href="https://github.com/infidel/ocaml-dns/blob/master/lwt/mdns_responder.ml#l586">https://github.com/infidel/ocaml-dns/blob/master/lwt/mdns_responder.ml#l586</a></div>
<div class="coderef">impl: <a href="https://github.com/infidel/ocaml-dns/blob/master/mirage/mdns_resolver_mirage.ml#l39">https://github.com/infidel/ocaml-dns/blob/master/mirage/mdns_resolver_mirage.ml#l39</a></div>
<div class="note">Untested</div>
</div>

<div class="clause" id="s6_p4_c3"><span class="label">s6_p4_c3</span>Multicast DNS queriers receiving Multicast DNS responses do not care what question elicited the response; they care only that the information in the response is true and accurate.</div>
</div>

<div class="paragraph" id="s6_p5">
<div class="clause should" id="s6_p5_c1"><span class="label">s6_p5_c1</span>A Multicast DNS responder on Ethernet [IEEE.802.3] and similar shared multiple access networks SHOULD have the capability of delaying its responses by up to 500 ms, as described below.</div>
</div>

<div class="paragraph" id="s6_p6">
<div class="clause" id="s6_p6_c1"><span class="label">s6_p6_c1</span>If a large number of Multicast DNS responders were all to respond immediately to a particular query, a collision would be virtually guaranteed.</div>
<div class="clause" id="s6_p6_c2"><span class="label">s6_p6_c2</span>By imposing a small random delay, the number of collisions is dramatically reduced.</div>
<div class="clause" id="s6_p6_c3"><span class="label">s6_p6_c3</span>On a full-sized Ethernet using the maximum cable lengths allowed and the maximum number of repeaters allowed, an Ethernet frame is vulnerable to collisions during the transmission of its first 256 bits.</div>
<div class="clause" id="s6_p6_c4"><span class="label">s6_p6_c4</span>On 10 Mb/s Ethernet, this equates to a vulnerable time window of 25.6 microseconds.</div>
<div class="clause" id="s6_p6_c5"><span class="label">s6_p6_c5</span>On higher- speed variants of Ethernet, the vulnerable time window is shorter.</div>
</div>

<div class="paragraph" id="s6_p7">
<div class="clause should" id="s6_p7_c1"><span class="label">s6_p7_c1</span>In the case where a Multicast DNS responder has good reason to believe that it will be the only responder on the link that will send a response (i.e., because it is able to answer every question in the query message, and for all of those answer records it has previously verified that the name, rrtype, and rrclass are unique on the link), it SHOULD NOT impose any random delay before responding, and SHOULD normally generate its response within at most 10 ms.</div>
<div class="clause" id="s6_p7_c2"><span class="label">s6_p7_c2</span>In particular, this applies to responding to probe queries with the unicast-response bit set.</div>
<div class="clause" id="s6_p7_c3"><span class="label">s6_p7_c3</span>Since receiving a probe query gives a clear indication that some other responder is planning to start using this name in the very near future, answering such probe queries to defend a unique record is a high priority and needs to be done without delay.</div>
<div class="clause" id="s6_p7_c4"><span class="label">s6_p7_c4</span>A probe query can be distinguished from a normal query by the fact that a probe query contains a proposed record in the Authority Section that answers the question in the Question Section (for more details, see Section 8.2, "Simultaneous Probe Tiebreaking").</div>
</div>

<div class="paragraph" id="s6_p8">
<div class="clause" id="s6_p8_c1"><span class="label">s6_p8_c1</span>Responding without delay is appropriate for records like the address record for a particular host name, when the host name has been previously verified unique.</div>
<div class="clause" id="s6_p8_c2"><span class="label">s6_p8_c2</span>Responding without delay is *not* appropriate for things like looking up PTR records used for DNS-Based Service Discovery [RFC6763], where a large number of responses may be anticipated.</div>
</div>

<div class="paragraph" id="s6_p9">
<div class="clause should" id="s6_p9_c1"><span class="label">s6_p9_c1</span>In any case where there may be multiple responses, such as queries where the answer is a member of a shared resource record set, each responder SHOULD delay its response by a random amount of time selected with uniform random distribution in the range 20-120 ms.</div>
<div class="clause" id="s6_p9_c2"><span class="label">s6_p9_c2</span>The reason for requiring that the delay be at least 20 ms is to accommodate the situation where two or more query packets are sent back-to-back, because in that case we want a responder with answers to more than one of those queries to have the opportunity to aggregate all of its answers into a single response message.</div>
</div>

<div class="paragraph" id="s6_p10">
<div class="clause should" id="s6_p10_c1"><span class="label">s6_p10_c1</span>In the case where the query has the TC (truncated) bit set, indicating that subsequent Known-Answer packets will follow, responders SHOULD delay their responses by a random amount of time selected with uniform random distribution in the range 400-500 ms, to allow enough time for all the Known-Answer packets to arrive, as described in Section 7.2, "Multipacket Known-Answer Suppression".</div>
</div>

<div class="paragraph" id="s6_p11">
<div class="clause must" id="s6_p11_c1"><span class="label">s6_p11_c1</span>The source UDP port in all Multicast DNS responses MUST be 5353 (the well-known port assigned to mDNS).</div>
<div class="clause must" id="s6_p11_c2"><span class="label">s6_p11_c2</span>Multicast DNS implementations MUST silently ignore any Multicast DNS responses they receive where the source UDP port is not 5353.</div>
</div>

<div class="paragraph" id="s6_p12">
<div class="clause must" id="s6_p12_c1"><span class="label">s6_p12_c1</span>The destination UDP port in all Multicast DNS responses MUST be 5353, and the destination address MUST be the mDNS IPv4 link-local multicast address 224.0.0.251 or its IPv6 equivalent FF02::FB, except when generating a reply to a query that explicitly requested a unicast response:</div>
</div>

<div class="paragraph" id="s6_p13">
<div class="clause" id="s6_p13_c1"><span class="label">s6_p13_c1</span>* via the unicast-response bit, * by virtue of being a legacy query (Section 6.7), or * by virtue of being a direct unicast query.</div>
</div>

<div class="paragraph" id="s6_p14">
<div class="clause must" id="s6_p14_c1"><span class="label">s6_p14_c1</span>Except for these three specific cases, responses MUST NOT be sent via unicast, because then the "Passive Observation of Failures" mechanisms described in Section 10.5 would not work correctly.</div>
<div class="clause" id="s6_p14_c2"><span class="label">s6_p14_c2</span>Other benefits of sending responses via multicast are discussed in Appendix D.</div>
<div class="clause must" id="s6_p14_c3"><span class="label">s6_p14_c3</span>A Multicast DNS querier MUST only accept unicast responses if they answer a recently sent query (e.g., sent within the last two seconds) that explicitly requested unicast responses.</div>
<div class="clause must" id="s6_p14_c4"><span class="label">s6_p14_c4</span>A Multicast DNS querier MUST silently ignore all other unicast responses.</div>
</div>

<div class="paragraph" id="s6_p15">
<div class="clause must" id="s6_p15_c1"><span class="label">s6_p15_c1</span>To protect the network against excessive packet flooding due to software bugs or malicious attack, a Multicast DNS responder MUST NOT (except in the one special case of answering probe queries) multicast a record on a given interface until at least one second has elapsed since the last time that record was multicast on that particular interface.</div>
<div class="clause" id="s6_p15_c2"><span class="label">s6_p15_c2</span>A legitimate querier on the network should have seen the previous transmission and cached it.</div>
<div class="clause" id="s6_p15_c3"><span class="label">s6_p15_c3</span>A querier that did not receive and cache the previous transmission will retry its request and receive a subsequent response.</div>
<div class="clause must" id="s6_p15_c4"><span class="label">s6_p15_c4</span>In the special case of answering probe queries, because of the limited time before the probing host will make its decision about whether or not to use the name, a Multicast DNS responder MUST respond quickly.</div>
<div class="clause" id="s6_p15_c5"><span class="label">s6_p15_c5</span>In this special case only, when responding via multicast to a probe, a Multicast DNS responder is only required to delay its transmission as necessary to ensure an interval of at least 250 ms since the last time the record was multicast on that interface.</div>
</div>

<h2 id="s6.1">6.1 Negative Responses</h2>

<a name="s6.1" /><div class="paragraph" id="s6.1_p1">
<div class="clause" id="s6.1_p1_c1"><span class="label">s6.1_p1_c1</span>In the early design of Multicast DNS it was assumed that explicit negative responses would never be needed.</div>
<div class="clause" id="s6.1_p1_c2"><span class="label">s6.1_p1_c2</span>A host can assert the existence of the set of records that it claims to exist, and the union of all such sets on a link is the set of Multicast DNS records that exist on that link.</div>
<div class="clause" id="s6.1_p1_c3"><span class="label">s6.1_p1_c3</span>Asserting the nonexistence of every record in the complement of that set -- i.e., all possible Multicast DNS records that could exist on this link but do not at this moment -- was felt to be impractical and unnecessary.</div>
<div class="clause" id="s6.1_p1_c4"><span class="label">s6.1_p1_c4</span>The nonexistence of a record would be ascertained by a querier querying for it and failing to receive a response from any of the hosts currently attached to the link.</div>
</div>

<div class="paragraph" id="s6.1_p2">
<div class="clause" id="s6.1_p2_c1"><span class="label">s6.1_p2_c1</span>However, operational experience showed that explicit negative responses can sometimes be valuable.</div>
<div class="clause" id="s6.1_p2_c2"><span class="label">s6.1_p2_c2</span>One such example is when a querier is querying for a AAAA record, and the host name in question has no associated IPv6 addresses.</div>
<div class="clause" id="s6.1_p2_c3"><span class="label">s6.1_p2_c3</span>In this case, the responding host knows it currently has exclusive ownership of that name, and it knows that it currently does not have any IPv6 addresses, so an explicit negative response is preferable to the querier having to retransmit its query multiple times, and eventually give up with a timeout, before it can conclude that a given AAAA record does not exist.</div>
</div>

<div class="paragraph" id="s6.1_p3">
<div class="clause must" id="s6.1_p3_c1"><span class="label">s6.1_p3_c1</span>Any time a responder receives a query for a name for which it has verified exclusive ownership, for a type for which that name has no records, the responder MUST (except as allowed in (a) below) respond asserting the nonexistence of that record using a DNS NSEC record [RFC4034].</div>
<div class="clause" id="s6.1_p3_c2"><span class="label">s6.1_p3_c2</span>In the case of Multicast DNS the NSEC record is not being used for its usual DNSSEC [RFC4033] security properties, but simply as a way of expressing which records do or do not exist with a given name.</div>
</div>

<div class="paragraph" id="s6.1_p4">
<div class="clause may" id="s6.1_p4_c1"><span class="label">s6.1_p4_c1</span>On receipt of a question for a particular name, rrtype, and rrclass, for which a responder does have one or more unique answers, the responder MAY also include an NSEC record in the Additional Record Section indicating the nonexistence of other rrtypes for that name and rrclass.</div>
</div>

<div class="paragraph" id="s6.1_p5">
<div class="clause may" id="s6.1_p5_c1"><span class="label">s6.1_p5_c1</span>Implementers working with devices with sufficient memory and CPU resources MAY choose to implement code to handle the full generality of the DNS NSEC record [RFC4034], including bitmaps up to 65,536 bits long.</div>
<div class="clause must" id="s6.1_p5_c2"><span class="label">s6.1_p5_c2</span>To facilitate use by devices with limited memory and CPU resources, Multicast DNS queriers are only REQUIRED to be able to parse a restricted form of the DNS NSEC record.</div>
<div class="clause must" id="s6.1_p5_c3"><span class="label">s6.1_p5_c3</span>All compliant Multicast DNS implementations MUST at least correctly generate and parse the restricted DNS NSEC record format described below:</div>
</div>

<div class="paragraph" id="s6.1_p6">
<div class="clause" id="s6.1_p6_c1"><span class="label">s6.1_p6_c1</span>o The 'Next Domain Name' field contains the record's own name.</div>
<div class="clause" id="s6.1_p6_c2"><span class="label">s6.1_p6_c2</span>When used with name compression, this means that the 'Next Domain Name' field always takes exactly two bytes in the message.</div>
</div>

<div class="paragraph" id="s6.1_p7">
<div class="clause" id="s6.1_p7_c1"><span class="label">s6.1_p7_c1</span>o The Type Bit Map block number is 0.</div>
</div>

<div class="paragraph" id="s6.1_p8">
<div class="clause" id="s6.1_p8_c1"><span class="label">s6.1_p8_c1</span>o The Type Bit Map block length byte is a value in the range 1-32.</div>
</div>

<div class="paragraph" id="s6.1_p9">
<div class="clause" id="s6.1_p9_c1"><span class="label">s6.1_p9_c1</span>o The Type Bit Map data is 1-32 bytes, as indicated by length byte.</div>
</div>

<div class="paragraph" id="s6.1_p10">
<div class="clause" id="s6.1_p10_c1"><span class="label">s6.1_p10_c1</span>Because this restricted form of the DNS NSEC record is limited to Type Bit Map block number zero, it cannot express the existence of rrtypes above 255.</div>
<div class="clause must" id="s6.1_p10_c2"><span class="label">s6.1_p10_c2</span>Consequently, if a Multicast DNS responder were to have records with rrtypes above 255, it MUST NOT generate these restricted-form NSEC records for those names, since to do so would imply that the name has no records with rrtypes above 255, which would be false.</div>
<div class="clause must" id="s6.1_p10_c3"><span class="label">s6.1_p10_c3</span>In such cases a Multicast DNS responder MUST either (a) emit no NSEC record for that name, or (b) emit a full NSEC record containing the appropriate Type Bit Map block(s) with the correct bits set for all the record types that exist.</div>
<div class="clause" id="s6.1_p10_c4"><span class="label">s6.1_p10_c4</span>In practice this is not a significant limitation, since rrtypes above 255 are not currently in widespread use.</div>
</div>

<div class="paragraph" id="s6.1_p11">
<div class="clause should" id="s6.1_p11_c1"><span class="label">s6.1_p11_c1</span>If a Multicast DNS implementation receives an NSEC record where the 'Next Domain Name' field is not the record's own name, then the implementation SHOULD ignore the 'Next Domain Name' field and process the remainder of the NSEC record as usual.</div>
<div class="clause must" id="s6.1_p11_c2"><span class="label">s6.1_p11_c2</span>In Multicast DNS the 'Next Domain Name' field is not currently used, but it could be used in a future version of this protocol, which is why a Multicast DNS implementation MUST NOT reject or ignore an NSEC record it receives just because it finds an unexpected value in the 'Next Domain Name' field.</div>
</div>

<div class="paragraph" id="s6.1_p12">
<div class="clause may" id="s6.1_p12_c1"><span class="label">s6.1_p12_c1</span>If a Multicast DNS implementation receives an NSEC record containing more than one Type Bit Map, or where the Type Bit Map block number is not zero, or where the block length is not in the range 1-32, then the Multicast DNS implementation MAY silently ignore the entire NSEC record.</div>
<div class="clause must" id="s6.1_p12_c2"><span class="label">s6.1_p12_c2</span>A Multicast DNS implementation MUST NOT ignore an entire message just because that message contains one or more NSEC record(s) that the Multicast DNS implementation cannot parse.</div>
<div class="clause" id="s6.1_p12_c3"><span class="label">s6.1_p12_c3</span>This provision is to allow future enhancements to the protocol to be introduced in a backwards-compatible way that does not break compatibility with older Multicast DNS implementations.</div>
</div>

<div class="paragraph" id="s6.1_p13">
<div class="clause must" id="s6.1_p13_c1"><span class="label">s6.1_p13_c1</span>To help differentiate these synthesized NSEC records (generated programmatically on-the-fly) from conventional Unicast DNS NSEC records (which actually exist in a signed DNS zone), the synthesized Multicast DNS NSEC records MUST NOT have the NSEC bit set in the Type Bit Map, whereas conventional Unicast DNS NSEC records do have the NSEC bit set.</div>
</div>

<div class="paragraph" id="s6.1_p14">
<div class="clause" id="s6.1_p14_c1"><span class="label">s6.1_p14_c1</span>The TTL of the NSEC record indicates the intended lifetime of the negative cache entry.</div>
<div class="clause should" id="s6.1_p14_c2"><span class="label">s6.1_p14_c2</span>In general, the TTL given for an NSEC record SHOULD be the same as the TTL that the record would have had, had it existed.</div>
<div class="clause" id="s6.1_p14_c3"><span class="label">s6.1_p14_c3</span>For example, the TTL for address records in Multicast DNS is typically 120 seconds (see Section 10), so the negative cache lifetime for an address record that does not exist should also be 120 seconds.</div>
</div>

<div class="paragraph" id="s6.1_p15">
<div class="clause must" id="s6.1_p15_c1"><span class="label">s6.1_p15_c1</span>A responder MUST only generate negative responses to queries for which it has legitimate ownership of the name, rrtype, and rrclass in question, and can legitimately assert that no record with that name, rrtype, and rrclass exists.</div>
<div class="clause" id="s6.1_p15_c2"><span class="label">s6.1_p15_c2</span>A responder can assert that a specified rrtype does not exist for one of its names if it knows a priori that it has exclusive ownership of that name (e.g., names of reverse address mapping PTR records, which are derived from IP addresses, which should be unique on the local link) or if it previously claimed unique ownership of that name using probe queries for rrtype "ANY".</div>
<div class="clause" id="s6.1_p15_c3"><span class="label">s6.1_p15_c3</span>(If it were to use probe queries for a specific rrtype, then it would only own the name for that rrtype, and could not assert that other rrtypes do not exist.)</div>
</div>

<div class="paragraph" id="s6.1_p16">
<div class="clause" id="s6.1_p16_c1"><span class="label">s6.1_p16_c1</span>The design rationale for this mechanism for encoding negative responses is discussed further in Appendix E.</div>
</div>

<h2 id="s6.2">6.2 Responding to Address Queries</h2>

<a name="s6.2" /><div class="paragraph" id="s6.2_p1">
<div class="clause must" id="s6.2_p1_c1"><span class="label">s6.2_p1_c1</span>When a Multicast DNS responder sends a Multicast DNS response message containing its own address records, it MUST include all addresses that are valid on the interface on which it is sending the message, and MUST NOT include addresses that are not valid on that interface (such as addresses that may be configured on the host's other interfaces).</div>
<div class="clause" id="s6.2_p1_c2"><span class="label">s6.2_p1_c2</span>For example, if an interface has both an IPv6 link- local and an IPv6 routable address, both should be included in the response message so that queriers receive both and can make their own choice about which to use.</div>
<div class="clause" id="s6.2_p1_c3"><span class="label">s6.2_p1_c3</span>This allows a querier that only has an IPv6 link-local address to connect to the link-local address, and a different querier that has an IPv6 routable address to connect to the IPv6 routable address instead.</div>
</div>

<div class="paragraph" id="s6.2_p2">
<div class="clause should" id="s6.2_p2_c1"><span class="label">s6.2_p2_c1</span>When a Multicast DNS responder places an IPv4 or IPv6 address record (rrtype "A" or "AAAA") into a response message, it SHOULD also place any records of the other address type with the same name into the additional section, if there is space in the message.</div>
<div class="clause" id="s6.2_p2_c2"><span class="label">s6.2_p2_c2</span>This is to provide fate sharing, so that all a device's addresses are delivered atomically in a single message, to reduce the risk that packet loss could cause a querier to receive only the IPv4 addresses and not the IPv6 addresses, or vice versa.</div>
</div>

<div class="paragraph" id="s6.2_p3">
<div class="clause should" id="s6.2_p3_c1"><span class="label">s6.2_p3_c1</span>In the event that a device has only IPv4 addresses but no IPv6 addresses, or vice versa, then the appropriate NSEC record SHOULD be placed into the additional section, so that queriers can know with certainty that the device has no addresses of that kind.</div>
</div>

<div class="paragraph" id="s6.2_p4">
<div class="clause" id="s6.2_p4_c1"><span class="label">s6.2_p4_c1</span>Some Multicast DNS responders treat a physical interface with both IPv4 and IPv6 address as a single interface with two addresses.</div>
<div class="clause must" id="s6.2_p4_c2"><span class="label">s6.2_p4_c2</span>Other Multicast DNS responders may treat this case as logically two interfaces (one with one or more IPv4 addresses, and the other with one or more IPv6 addresses), but responders that operate this way MUST NOT put the corresponding automatic NSEC records in replies they send (i.e., a negative IPv4 assertion in their IPv6 responses, and a negative IPv6 assertion in their IPv4 responses) because this would cause incorrect operation in responders on the network that work the former way.</div>
</div>

<h2 id="s6.3">6.3 Responding to Multiquestion Queries</h2>

<a name="s6.3" /><div class="paragraph" id="s6.3_p1">
<div class="clause must" id="s6.3_p1_c1"><span class="label">s6.3_p1_c1</span>Multicast DNS responders MUST correctly handle DNS query messages containing more than one question, by answering any or all of the questions to which they have answers.</div>
<div class="clause should" id="s6.3_p1_c2"><span class="label">s6.3_p1_c2</span>Unlike single-question queries, where responding without delay is allowed in appropriate cases, for query messages containing more than one question, all (non-defensive) answers SHOULD be randomly delayed in the range 20-120 ms, or 400-500 ms if the TC (truncated) bit is set.</div>
<div class="clause" id="s6.3_p1_c3"><span class="label">s6.3_p1_c3</span>This is because when a query message contains more than one question, a Multicast DNS responder cannot generally be certain that other responders will not also be simultaneously generating answers to other questions in that query message.</div>
<div class="clause" id="s6.3_p1_c4"><span class="label">s6.3_p1_c4</span>(Answers defending a name, in response to a probe for that name, are not subject to this delay rule and are still sent immediately.)</div>
</div>

<h2 id="s6.4">6.4 Response Aggregation</h2>

<a name="s6.4" /><div class="paragraph" id="s6.4_p1">
<div class="clause should" id="s6.4_p1_c1"><span class="label">s6.4_p1_c1</span>When possible, a responder SHOULD, for the sake of network efficiency, aggregate as many responses as possible into a single Multicast DNS response message.</div>
<div class="clause should" id="s6.4_p1_c2"><span class="label">s6.4_p1_c2</span>For example, when a responder has several responses it plans to send, each delayed by a different interval, then earlier responses SHOULD be delayed by up to an additional 500 ms if that will permit them to be aggregated with other responses scheduled to go out a little later.</div>
</div>

<h2 id="s6.5">6.5 Wildcard Queries (qtype "ANY" and qclass "ANY")</h2>

<a name="s6.5" /><div class="paragraph" id="s6.5_p1">
<div class="clause must" id="s6.5_p1_c1"><span class="label">s6.5_p1_c1</span>When responding to queries using qtype "ANY" (255) and/or qclass "ANY" (255), a Multicast DNS responder MUST respond with *ALL* of its records that match the query.</div>
<div class="clause" id="s6.5_p1_c2"><span class="label">s6.5_p1_c2</span>This is subtly different from how qtype "ANY" and qclass "ANY" work in Unicast DNS.</div>
</div>

<div class="paragraph" id="s6.5_p2">
<div class="clause" id="s6.5_p2_c1"><span class="label">s6.5_p2_c1</span>A common misconception is that a Unicast DNS query for qtype "ANY" will elicit a response containing all matching records.</div>
<div class="clause" id="s6.5_p2_c2"><span class="label">s6.5_p2_c2</span>This is incorrect.</div>
<div class="clause" id="s6.5_p2_c3"><span class="label">s6.5_p2_c3</span>If there are any records that match the query, the response is required only to contain at least one of them, not necessarily all of them.</div>
</div>

<div class="paragraph" id="s6.5_p3">
<div class="clause" id="s6.5_p3_c1"><span class="label">s6.5_p3_c1</span>This somewhat surprising behavior is commonly seen with caching (i.e., "recursive") name servers.</div>
<div class="clause" id="s6.5_p3_c2"><span class="label">s6.5_p3_c2</span>If a caching server receives a qtype "ANY" query for which it has at least one valid answer, it is allowed to return only those matching answers it happens to have already in its cache, and it is not required to reconsult the authoritative name server to check if there are any more records that also match the qtype "ANY" query.</div>
</div>

<div class="paragraph" id="s6.5_p4">
<div class="clause" id="s6.5_p4_c1"><span class="label">s6.5_p4_c1</span>For example, one might imagine that a query for qtype "ANY" for name "host.example.com" would return both the IPv4 (A) and the IPv6 (AAAA) address records for that host.</div>
<div class="clause" id="s6.5_p4_c2"><span class="label">s6.5_p4_c2</span>In reality, what happens is that it depends on the history of what queries have been previously received by intervening caching servers.</div>
<div class="clause" id="s6.5_p4_c3"><span class="label">s6.5_p4_c3</span>If a caching server has no records for "host.example.com", then it will consult another server (usually the authoritative name server for the name in question), and, in that case, it will typically return all IPv4 and IPv6 address records.</div>
<div class="clause" id="s6.5_p4_c4"><span class="label">s6.5_p4_c4</span>However, if some other host has recently done a query for qtype "A" for name "host.example.com", so that the caching server already has IPv4 address records for "host.example.com" in its cache but no IPv6 address records, then it will return only the IPv4 address records it already has cached, and no IPv6 address records.</div>
</div>

<div class="paragraph" id="s6.5_p5">
<div class="clause" id="s6.5_p5_c1"><span class="label">s6.5_p5_c1</span>Multicast DNS does not share this property that qtype "ANY" and qclass "ANY" queries return some undefined subset of the matching records.</div>
<div class="clause must" id="s6.5_p5_c2"><span class="label">s6.5_p5_c2</span>When responding to queries using qtype "ANY" (255) and/or qclass "ANY" (255), a Multicast DNS responder MUST respond with *ALL* of its records that match the query.</div>
</div>

<h2 id="s6.6">6.6 Cooperating Multicast DNS Responders</h2>

<a name="s6.6" /><div class="paragraph" id="s6.6_p1">
<div class="clause" id="s6.6_p1_c1"><span class="label">s6.6_p1_c1</span>If a Multicast DNS responder ("A") observes some other Multicast DNS responder ("B") send a Multicast DNS response message containing a resource record with the same name, rrtype, and rrclass as one of A's resource records, but *different* rdata, then:</div>
</div>

<div class="paragraph" id="s6.6_p2">
<div class="clause" id="s6.6_p2_c1"><span class="label">s6.6_p2_c1</span>o If A's resource record is intended to be a shared resource record, then this is no conflict, and no action is required.</div>
</div>

<div class="paragraph" id="s6.6_p3">
<div class="clause must" id="s6.6_p3_c1"><span class="label">s6.6_p3_c1</span>o If A's resource record is intended to be a member of a unique resource record set owned solely by that responder, then this is a conflict and MUST be handled as described in Section 9, "Conflict Resolution".</div>
</div>

<div class="paragraph" id="s6.6_p4">
<div class="clause" id="s6.6_p4_c1"><span class="label">s6.6_p4_c1</span>If a Multicast DNS responder ("A") observes some other Multicast DNS responder ("B") send a Multicast DNS response message containing a resource record with the same name, rrtype, and rrclass as one of A's resource records, and *identical* rdata, then:</div>
</div>

<div class="paragraph" id="s6.6_p5">
<div class="clause" id="s6.6_p5_c1"><span class="label">s6.6_p5_c1</span>o If the TTL of B's resource record given in the message is at least half the true TTL from A's point of view, then no action is required.</div>
</div>

<div class="paragraph" id="s6.6_p6">
<div class="clause must" id="s6.6_p6_c1"><span class="label">s6.6_p6_c1</span>o If the TTL of B's resource record given in the message is less than half the true TTL from A's point of view, then A MUST mark its record to be announced via multicast.</div>
<div class="clause" id="s6.6_p6_c2"><span class="label">s6.6_p6_c2</span>Queriers receiving the record from B would use the TTL given by B and, hence, may delete the record sooner than A expects.</div>
<div class="clause" id="s6.6_p6_c3"><span class="label">s6.6_p6_c3</span>By sending its own multicast response correcting the TTL, A ensures that the record will be retained for the desired time.</div>
</div>

<div class="paragraph" id="s6.6_p7">
<div class="clause" id="s6.6_p7_c1"><span class="label">s6.6_p7_c1</span>These rules allow multiple Multicast DNS responders to offer the same data on the network (perhaps for fault-tolerance reasons) without conflicting with each other.</div>
</div>

<h2 id="s6.7">6.7 Legacy Unicast Responses</h2>

<a name="s6.7" /><div class="paragraph" id="s6.7_p1">
<div class="clause" id="s6.7_p1_c1"><span class="label">s6.7_p1_c1</span>If the source UDP port in a received Multicast DNS query is not port 5353, this indicates that the querier originating the query is a simple resolver such as described in Section 5.1, "One-Shot Multicast DNS Queries", which does not fully implement all of Multicast DNS.</div>
<div class="clause must" id="s6.7_p1_c2"><span class="label">s6.7_p1_c2</span>In this case, the Multicast DNS responder MUST send a UDP response directly back to the querier, via unicast, to the query packet's source IP address and port.</div>
<div class="clause must" id="s6.7_p1_c3"><span class="label">s6.7_p1_c3</span>This unicast response MUST be a conventional unicast response as would be generated by a conventional Unicast DNS server; for example, it MUST repeat the query ID and the question given in the query message.</div>
<div class="clause must" id="s6.7_p1_c4"><span class="label">s6.7_p1_c4</span>In addition, the cache-flush bit described in Section 10.2, "Announcements to Flush Outdated Cache Entries", MUST NOT be set in legacy unicast responses.</div>
</div>

<div class="paragraph" id="s6.7_p2">
<div class="clause should" id="s6.7_p2_c1"><span class="label">s6.7_p2_c1</span>The resource record TTL given in a legacy unicast response SHOULD NOT be greater than ten seconds, even if the true TTL of the Multicast DNS resource record is higher.</div>
<div class="clause" id="s6.7_p2_c2"><span class="label">s6.7_p2_c2</span>This is because Multicast DNS responders that fully participate in the protocol use the cache coherency mechanisms described in Section 10, "Resource Record TTL Values and Cache Coherency", to update and invalidate stale data.</div>
<div class="clause" id="s6.7_p2_c3"><span class="label">s6.7_p2_c3</span>Were unicast responses sent to legacy resolvers to use the same high TTLs, these legacy resolvers, which do not implement these cache coherency mechanisms, could retain stale cached resource record data long after it is no longer valid.</div>
</div>

<h2 id="s7">7 Traffic Reduction</h2>

<a name="s7" /><div class="paragraph" id="s7_p1">
<div class="clause" id="s7_p1_c1"><span class="label">s7_p1_c1</span>A variety of techniques are used to reduce the amount of traffic on the network.</div>
</div>

<h2 id="s7.1">7.1 Known-Answer Suppression</h2>

<a name="s7.1" /><div class="paragraph" id="s7.1_p1">
<div class="clause" id="s7.1_p1_c1"><span class="label">s7.1_p1_c1</span>When a Multicast DNS querier sends a query to which it already knows some answers, it populates the Answer Section of the DNS query message with those answers.</div>
</div>

<div class="paragraph" id="s7.1_p2">
<div class="clause" id="s7.1_p2_c1"><span class="label">s7.1_p2_c1</span>Generally, this applies only to Shared records, not Unique records, since if a Multicast DNS querier already has at least one Unique record in its cache then it should not be expecting further different answers to this question, since the Unique record(s) it already has comprise the complete answer, so it has no reason to be sending the query at all.</div>
<div class="clause" id="s7.1_p2_c2"><span class="label">s7.1_p2_c2</span>In contrast, having some Shared records in its cache does not necessarily imply that a Multicast DNS querier will not receive further answers to this query, and it is in this case that it is beneficial to use the Known-Answer list to suppress repeated sending of redundant answers that the querier already knows.</div>
</div>

<div class="paragraph" id="s7.1_p3">
<div class="clause must" id="s7.1_p3_c1"><span class="label">s7.1_p3_c1</span>A Multicast DNS responder MUST NOT answer a Multicast DNS query if the answer it would give is already included in the Answer Section with an RR TTL at least half the correct value.</div>
<div class="clause must" id="s7.1_p3_c2"><span class="label">s7.1_p3_c2</span>If the RR TTL of the answer as given in the Answer Section is less than half of the true RR TTL as known by the Multicast DNS responder, the responder MUST send an answer so as to update the querier's cache before the record becomes in danger of expiration.</div>
</div>

<div class="paragraph" id="s7.1_p4">
<div class="clause" id="s7.1_p4_c1"><span class="label">s7.1_p4_c1</span>Because a Multicast DNS responder will respond if the remaining TTL given in the Known-Answer list is less than half the true TTL, it is superfluous for the querier to include such records in the Known- Answer list.</div>
<div class="clause should" id="s7.1_p4_c2"><span class="label">s7.1_p4_c2</span>Therefore, a Multicast DNS querier SHOULD NOT include records in the Known-Answer list whose remaining TTL is less than half of their original TTL.</div>
<div class="clause" id="s7.1_p4_c3"><span class="label">s7.1_p4_c3</span>Doing so would simply consume space in the message without achieving the goal of suppressing responses and would, therefore, be a pointless waste of network capacity.</div>
</div>

<div class="paragraph" id="s7.1_p5">
<div class="clause must" id="s7.1_p5_c1"><span class="label">s7.1_p5_c1</span>A Multicast DNS querier MUST NOT cache resource records observed in the Known-Answer Section of other Multicast DNS queries.</div>
<div class="clause" id="s7.1_p5_c2"><span class="label">s7.1_p5_c2</span>The Answer Section of Multicast DNS queries is not authoritative.</div>
<div class="clause" id="s7.1_p5_c3"><span class="label">s7.1_p5_c3</span>By placing information in the Answer Section of a Multicast DNS query, the querier is stating that it *believes* the information to be true.</div>
<div class="clause" id="s7.1_p5_c4"><span class="label">s7.1_p5_c4</span>It is not asserting that the information *is* true.</div>
<div class="clause" id="s7.1_p5_c5"><span class="label">s7.1_p5_c5</span>Some of those records may have come from other hosts that are no longer on the network.</div>
<div class="clause" id="s7.1_p5_c6"><span class="label">s7.1_p5_c6</span>Propagating that stale information to other Multicast DNS queriers on the network would not be helpful.</div>
</div>

<h2 id="s7.2">7.2 Multipacket Known-Answer Suppression</h2>

<a name="s7.2" /><div class="paragraph" id="s7.2_p1">
<div class="clause" id="s7.2_p1_c1"><span class="label">s7.2_p1_c1</span>Sometimes a Multicast DNS querier will already have too many answers to fit in the Known-Answer Section of its query packets.</div>
<div class="clause" id="s7.2_p1_c2"><span class="label">s7.2_p1_c2</span>In this case, it should issue a Multicast DNS query containing a question and as many Known-Answer records as will fit.</div>
<div class="clause must" id="s7.2_p1_c3"><span class="label">s7.2_p1_c3</span>It MUST then set the TC (Truncated) bit in the header before sending the query.</div>
<div class="clause must" id="s7.2_p1_c4"><span class="label">s7.2_p1_c4</span>It MUST immediately follow the packet with another query packet containing no questions and as many more Known-Answer records as will fit.</div>
<div class="clause" id="s7.2_p1_c5"><span class="label">s7.2_p1_c5</span>If there are still too many records remaining to fit in the packet, it again sets the TC bit and continues until all the Known-Answer records have been sent.</div>
</div>

<div class="paragraph" id="s7.2_p2">
<div class="clause" id="s7.2_p2_c1"><span class="label">s7.2_p2_c1</span>A Multicast DNS responder seeing a Multicast DNS query with the TC bit set defers its response for a time period randomly selected in the interval 400-500 ms.</div>
<div class="clause" id="s7.2_p2_c2"><span class="label">s7.2_p2_c2</span>This gives the Multicast DNS querier time to send additional Known-Answer packets before the responder responds.</div>
<div class="clause must" id="s7.2_p2_c3"><span class="label">s7.2_p2_c3</span>If the responder sees any of its answers listed in the Known-Answer lists of subsequent packets from the querying host, it MUST delete that answer from the list of answers it is planning to give (provided that no other host on the network has also issued a query for that record and is waiting to receive an answer).</div>
</div>

<div class="paragraph" id="s7.2_p3">
<div class="clause should" id="s7.2_p3_c1"><span class="label">s7.2_p3_c1</span>If the responder receives additional Known-Answer packets with the TC bit set, it SHOULD extend the delay as necessary to ensure a pause of 400-500 ms after the last such packet before it sends its answer.</div>
<div class="clause" id="s7.2_p3_c2"><span class="label">s7.2_p3_c2</span>This opens the potential risk that a continuous stream of Known- Answer packets could, theoretically, prevent a responder from answering indefinitely.</div>
<div class="clause" id="s7.2_p3_c3"><span class="label">s7.2_p3_c3</span>In practice, answers are never actually delayed significantly, and should a situation arise where significant delays did happen, that would be a scenario where the network is so overloaded that it would be desirable to err on the side of caution.</div>
<div class="clause" id="s7.2_p3_c4"><span class="label">s7.2_p3_c4</span>The consequence of delaying an answer may be that it takes a user longer than usual to discover all the services on the local network; in contrast, the consequence of incorrectly answering before all the Known-Answer packets have been received would be wasted capacity sending unnecessary answers on an already overloaded network.</div>
<div class="clause" id="s7.2_p3_c5"><span class="label">s7.2_p3_c5</span>In this (rare) situation, sacrificing speed to preserve reliable network operation is the right trade-off.</div>
</div>

<h2 id="s7.3">7.3 Duplicate Question Suppression</h2>

<a name="s7.3" /><div class="paragraph" id="s7.3_p1">
<div class="clause should" id="s7.3_p1_c1"><span class="label">s7.3_p1_c1</span>If a host is planning to transmit (or retransmit) a query, and it sees another host on the network send a query containing the same "QM" question, and the Known-Answer Section of that query does not contain any records that this host would not also put in its own Known-Answer Section, then this host SHOULD treat its own query as having been sent.</div>
<div class="clause" id="s7.3_p1_c2"><span class="label">s7.3_p1_c2</span>When multiple queriers on the network are querying for the same resource records, there is no need for them to all be repeatedly asking the same question.</div>
</div>

<h2 id="s7.4">7.4 Duplicate Answer Suppression</h2>

<a name="s7.4" /><div class="paragraph" id="s7.4_p1">
<div class="clause should" id="s7.4_p1_c1"><span class="label">s7.4_p1_c1</span>If a host is planning to send an answer, and it sees another host on the network send a response message containing the same answer record, and the TTL in that record is not less than the TTL this host would have given, then this host SHOULD treat its own answer as having been sent, and not also send an identical answer itself.</div>
<div class="clause" id="s7.4_p1_c2"><span class="label">s7.4_p1_c2</span>When multiple responders on the network have the same data, there is no need for all of them to respond.</div>
</div>

<div class="paragraph" id="s7.4_p2">
<div class="clause" id="s7.4_p2_c1"><span class="label">s7.4_p2_c1</span>The opportunity for duplicate answer suppression occurs when a host has received a query, and is delaying its response for some pseudo- random interval up to 500 ms, as described elsewhere in this document, and then, before the host sends its response, it sees some other host on the network send a response message containing the same answer record.</div>
</div>

<div class="paragraph" id="s7.4_p3">
<div class="clause" id="s7.4_p3_c1"><span class="label">s7.4_p3_c1</span>This feature is particularly useful when Multicast DNS Proxy Servers are in use, where there could be more than one proxy on the network giving Multicast DNS answers on behalf of some other host (e.g., because that other host is currently asleep and is not itself responding to queries).</div>
</div>

<h2 id="s8">8 Probing and Announcing on Startup</h2>

<a name="s8" /><div class="paragraph" id="s8_p1">
<div class="clause" id="s8_p1_c1"><span class="label">s8_p1_c1</span>Typically a Multicast DNS responder should have, at the very least, address records for all of its active interfaces.</div>
<div class="clause" id="s8_p1_c2"><span class="label">s8_p1_c2</span>Creating and advertising an HINFO record on each interface as well can be useful to network administrators.</div>
</div>

<div class="paragraph" id="s8_p2">
<div class="clause must" id="s8_p2_c1"><span class="label">s8_p2_c1</span>Whenever a Multicast DNS responder starts up, wakes up from sleep, receives an indication of a network interface "Link Change" event, or has any other reason to believe that its network connectivity may have changed in some relevant way, it MUST perform the two startup steps below: Probing (Section 8.1) and Announcing (Section 8.3).</div>
</div>

<h2 id="s8.1">8.1 Probing</h2>

<a name="s8.1" /><div class="paragraph" id="s8.1_p1">
<div class="clause must" id="s8.1_p1_c1"><span class="label">s8.1_p1_c1</span>The first startup step is that, for all those resource records that a Multicast DNS responder desires to be unique on the local link, it MUST send a Multicast DNS query asking for those resource records, to see if any of them are already in use.</div>
<div class="clause" id="s8.1_p1_c2"><span class="label">s8.1_p1_c2</span>The primary example of this is a host's address records, which map its unique host name to its unique IPv4 and/or IPv6 addresses.</div>
<div class="clause should" id="s8.1_p1_c3"><span class="label">s8.1_p1_c3</span>All probe queries SHOULD be done using the desired resource record name and class (usually class 1, "Internet"), and query type "ANY" (255), to elicit answers for all types of records with that name.</div>
<div class="clause" id="s8.1_p1_c4"><span class="label">s8.1_p1_c4</span>This allows a single question to be used in place of several questions, which is more efficient on the network.</div>
<div class="clause" id="s8.1_p1_c5"><span class="label">s8.1_p1_c5</span>It also allows a host to verify exclusive ownership of a name for all rrtypes, which is desirable in most cases.</div>
<div class="clause" id="s8.1_p1_c6"><span class="label">s8.1_p1_c6</span>It would be confusing, for example, if one host owned the "A" record for "myhost.local.", but a different host owned the "AAAA" record for that name.</div>
</div>

<div class="paragraph" id="s8.1_p2">
<div class="clause" id="s8.1_p2_c1"><span class="label">s8.1_p2_c1</span>The ability to place more than one question in a Multicast DNS query is useful here, because it can allow a host to use a single message to probe for all of its resource records instead of needing a separate message for each.</div>
<div class="clause" id="s8.1_p2_c2"><span class="label">s8.1_p2_c2</span>For example, a host can simultaneously probe for uniqueness of its "A" record and all its SRV records [RFC6763] in the same query message.</div>
</div>

<div class="paragraph" id="s8.1_p3">
<div class="clause" id="s8.1_p3_c1"><span class="label">s8.1_p3_c1</span>When ready to send its Multicast DNS probe packet(s) the host should first wait for a short random delay time, uniformly distributed in the range 0-250 ms.</div>
<div class="clause" id="s8.1_p3_c2"><span class="label">s8.1_p3_c2</span>This random delay is to guard against the case where several devices are powered on simultaneously, or several devices are connected to an Ethernet hub, which is then powered on, or some other external event happens that might cause a group of hosts to all send synchronized probes.</div>
</div>

<div class="paragraph" id="s8.1_p4">
<div class="clause" id="s8.1_p4_c1"><span class="label">s8.1_p4_c1</span>250 ms after the first query, the host should send a second; then, 250 ms after that, a third.</div>
<div class="clause" id="s8.1_p4_c2"><span class="label">s8.1_p4_c2</span>If, by 250 ms after the third probe, no conflicting Multicast DNS responses have been received, the host may move to the next step, announcing.</div>
<div class="clause" id="s8.1_p4_c3"><span class="label">s8.1_p4_c3</span>(Note that probing is the one exception from the normal rule that there should be at least one second between repetitions of the same question, and the interval between subsequent repetitions should at least double.)</div>
</div>

<div class="paragraph" id="s8.1_p5">
<div class="clause must" id="s8.1_p5_c1"><span class="label">s8.1_p5_c1</span>When sending probe queries, a host MUST NOT consult its cache for potential answers.</div>
<div class="clause" id="s8.1_p5_c2"><span class="label">s8.1_p5_c2</span>Only conflicting Multicast DNS responses received "live" from the network are considered valid for the purposes of determining whether probing has succeeded or failed.</div>
</div>

<div class="paragraph" id="s8.1_p6">
<div class="clause" id="s8.1_p6_c1"><span class="label">s8.1_p6_c1</span>In order to allow services to announce their presence without unreasonable delay, the time window for probing is intentionally set quite short.</div>
<div class="clause" id="s8.1_p6_c2"><span class="label">s8.1_p6_c2</span>As a result of this, from the time the first probe packet is sent, another device on the network using that name has just 750 ms to respond to defend its name.</div>
<div class="clause" id="s8.1_p6_c3"><span class="label">s8.1_p6_c3</span>On networks that are slow, or busy, or both, it is possible for round-trip latency to account for a few hundred milliseconds, and software delays in slow devices can add additional delay.</div>
<div class="clause should" id="s8.1_p6_c4"><span class="label">s8.1_p6_c4</span>Hence, it is important that when a device receives a probe query for a name that it is currently using, it SHOULD generate its response to defend that name immediately and send it as quickly as possible.</div>
<div class="clause" id="s8.1_p6_c5"><span class="label">s8.1_p6_c5</span>The usual rules about random delays before responding, to avoid sudden bursts of simultaneous answers from different hosts, do not apply here since normally at most one host should ever respond to a given probe question.</div>
<div class="clause" id="s8.1_p6_c6"><span class="label">s8.1_p6_c6</span>Even when a single DNS query message contains multiple probe questions, it would be unusual for that message to elicit a defensive response from more than one other host.</div>
<div class="clause should" id="s8.1_p6_c7"><span class="label">s8.1_p6_c7</span>Because of the mDNS multicast rate-limiting rules, the probes SHOULD be sent as "QU" questions with the unicast- response bit set, to allow a defending host to respond immediately via unicast, instead of potentially having to wait before replying via multicast.</div>
</div>

<div class="paragraph" id="s8.1_p7">
<div class="clause must" id="s8.1_p7_c1"><span class="label">s8.1_p7_c1</span>During probing, from the time the first probe packet is sent until 250 ms after the third probe, if any conflicting Multicast DNS response is received, then the probing host MUST defer to the existing host, and SHOULD choose new names for some or all of its resource records as appropriate.</div>
<div class="clause must" id="s8.1_p7_c2"><span class="label">s8.1_p7_c2</span>Apparently conflicting Multicast DNS responses received *before* the first probe packet is sent MUST be silently ignored (see discussion of stale probe packets in Section 8.2, "Simultaneous Probe Tiebreaking", below).</div>
<div class="clause must" id="s8.1_p7_c3"><span class="label">s8.1_p7_c3</span>In the case of a host probing using query type "ANY" as recommended above, any answer containing a record with that name, of any type, MUST be considered a conflicting response and handled accordingly.</div>
</div>

<div class="paragraph" id="s8.1_p8">
<div class="clause must" id="s8.1_p8_c1"><span class="label">s8.1_p8_c1</span>If fifteen conflicts occur within any ten-second period, then the host MUST wait at least five seconds before each successive additional probe attempt.</div>
<div class="clause" id="s8.1_p8_c2"><span class="label">s8.1_p8_c2</span>This is to help ensure that, in the event of software bugs or other unanticipated problems, errant hosts do not flood the network with a continuous stream of multicast traffic.</div>
<div class="clause" id="s8.1_p8_c3"><span class="label">s8.1_p8_c3</span>For very simple devices, a valid way to comply with this requirement is to always wait five seconds after any failed probe attempt before trying again.</div>
</div>

<div class="paragraph" id="s8.1_p9">
<div class="clause should" id="s8.1_p9_c1"><span class="label">s8.1_p9_c1</span>If a responder knows by other means that its unique resource record set name, rrtype, and rrclass cannot already be in use by any other responder on the network, then it SHOULD skip the probing step for that resource record set.</div>
<div class="clause" id="s8.1_p9_c2"><span class="label">s8.1_p9_c2</span>For example, when creating the reverse address mapping PTR records, the host can reasonably assume that no other host will be trying to create those same PTR records, since that would imply that the two hosts were trying to use the same IP address, and if that were the case, the two hosts would be suffering communication problems beyond the scope of what Multicast DNS is designed to solve.</div>
<div class="clause should" id="s8.1_p9_c3"><span class="label">s8.1_p9_c3</span>Similarly, if a responder is acting as a proxy, taking over from another Multicast DNS responder that has already verified the uniqueness of the record, then the proxy SHOULD NOT repeat the probing step for those records.</div>
</div>

<h2 id="s8.2">8.2 Simultaneous Probe Tiebreaking</h2>

<a name="s8.2" /><div class="paragraph" id="s8.2_p1">
<div class="clause" id="s8.2_p1_c1"><span class="label">s8.2_p1_c1</span>The astute reader will observe that there is a race condition inherent in the previous description.</div>
<div class="clause" id="s8.2_p1_c2"><span class="label">s8.2_p1_c2</span>If two hosts are probing for the same name simultaneously, neither will receive any response to the probe, and the hosts could incorrectly conclude that they may both proceed to use the name.</div>
<div class="clause" id="s8.2_p1_c3"><span class="label">s8.2_p1_c3</span>To break this symmetry, each host populates the query message's Authority Section with the record or records with the rdata that it would be proposing to use, should its probing be successful.</div>
<div class="clause" id="s8.2_p1_c4"><span class="label">s8.2_p1_c4</span>The Authority Section is being used here in a way analogous to the way it is used as the "Update Section" in a DNS Update message [RFC2136] [RFC3007].</div>
</div>

<div class="paragraph" id="s8.2_p2">
<div class="clause" id="s8.2_p2_c1"><span class="label">s8.2_p2_c1</span>When a host is probing for a group of related records with the same name (e.g., the SRV and TXT record describing a DNS-SD service), only a single question need be placed in the Question Section, since query type "ANY" (255) is used, which will elicit answers for all records with that name.</div>
<div class="clause" id="s8.2_p2_c2"><span class="label">s8.2_p2_c2</span>However, for tiebreaking to work correctly in all cases, the Authority Section must contain *all* the records and proposed rdata being probed for uniqueness.</div>
</div>

<div class="paragraph" id="s8.2_p3">
<div class="clause" id="s8.2_p3_c1"><span class="label">s8.2_p3_c1</span>When a host that is probing for a record sees another host issue a query for the same record, it consults the Authority Section of that query.</div>
<div class="clause" id="s8.2_p3_c2"><span class="label">s8.2_p3_c2</span>If it finds any resource record(s) there which answers the query, then it compares the data of that (those) resource record(s) with its own tentative data.</div>
<div class="clause" id="s8.2_p3_c3"><span class="label">s8.2_p3_c3</span>We consider first the simple case of a host probing for a single record, receiving a simultaneous probe from another host also probing for a single record.</div>
<div class="clause" id="s8.2_p3_c4"><span class="label">s8.2_p3_c4</span>The two records are compared and the lexicographically later data wins.</div>
<div class="clause" id="s8.2_p3_c5"><span class="label">s8.2_p3_c5</span>This means that if the host finds that its own data is lexicographically later, it simply ignores the other host's probe.</div>
<div class="clause" id="s8.2_p3_c6"><span class="label">s8.2_p3_c6</span>If the host finds that its own data is lexicographically earlier, then it defers to the winning host by waiting one second, and then begins probing for this record again.</div>
<div class="clause" id="s8.2_p3_c7"><span class="label">s8.2_p3_c7</span>The logic for waiting one second and then trying again is to guard against stale probe packets on the network (possibly even stale probe packets sent moments ago by this host itself, before some configuration change, which may be echoed back after a short delay by some Ethernet switches and some 802.11 base stations).</div>
<div class="clause" id="s8.2_p3_c8"><span class="label">s8.2_p3_c8</span>If the winning simultaneous probe was from a real other host on the network, then after one second it will have completed its probing, and will answer subsequent probes.</div>
<div class="clause" id="s8.2_p3_c9"><span class="label">s8.2_p3_c9</span>If the apparently winning simultaneous probe was in fact just an old stale packet on the network (maybe from the host itself), then when it retries its probing in one second, its probes will go unanswered, and it will successfully claim the name.</div>
</div>

<div class="paragraph" id="s8.2_p4">
<div class="clause" id="s8.2_p4_c1"><span class="label">s8.2_p4_c1</span>The determination of "lexicographically later" is performed by first comparing the record class (excluding the cache-flush bit described in Section 10.2), then the record type, then raw comparison of the binary content of the rdata without regard for meaning or structure.</div>
<div class="clause" id="s8.2_p4_c2"><span class="label">s8.2_p4_c2</span>If the record classes differ, then the numerically greater class is considered "lexicographically later".</div>
<div class="clause" id="s8.2_p4_c3"><span class="label">s8.2_p4_c3</span>Otherwise, if the record types differ, then the numerically greater type is considered "lexicographically later".</div>
<div class="clause" id="s8.2_p4_c4"><span class="label">s8.2_p4_c4</span>If the rrtype and rrclass both match, then the rdata is compared.</div>
</div>

<div class="paragraph" id="s8.2_p5">
<div class="clause must" id="s8.2_p5_c1"><span class="label">s8.2_p5_c1</span>In the case of resource records containing rdata that is subject to name compression [RFC1035], the names MUST be uncompressed before comparison.</div>
<div class="clause" id="s8.2_p5_c2"><span class="label">s8.2_p5_c2</span>(The details of how a particular name is compressed is an artifact of how and where the record is written into the DNS message; it is not an intrinsic property of the resource record itself.)</div>
</div>

<div class="paragraph" id="s8.2_p6">
<div class="clause" id="s8.2_p6_c1"><span class="label">s8.2_p6_c1</span>The bytes of the raw uncompressed rdata are compared in turn, interpreting the bytes as eight-bit UNSIGNED values, until a byte is found whose value is greater than that of its counterpart (in which case, the rdata whose byte has the greater value is deemed lexicographically later) or one of the resource records runs out of rdata (in which case, the resource record which still has remaining data first is deemed lexicographically later).</div>
<div class="clause" id="s8.2_p6_c2"><span class="label">s8.2_p6_c2</span>The following is an example of a conflict:</div>
</div>

<div class="paragraph" id="s8.2_p7">
<div class="clause" id="s8.2_p7_c1"><span class="label">s8.2_p7_c1</span>MyPrinter.local.</div>
<div class="clause" id="s8.2_p7_c2"><span class="label">s8.2_p7_c2</span>A 169.254.99.200 MyPrinter.local.</div>
<div class="clause" id="s8.2_p7_c3"><span class="label">s8.2_p7_c3</span>A 169.254.200.50 In this case, 169.254.200.50 is lexicographically later (the third byte, with value 200, is greater than its counterpart with value 99), so it is deemed the winner.</div>
</div>

<div class="paragraph" id="s8.2_p8">
<div class="clause" id="s8.2_p8_c1"><span class="label">s8.2_p8_c1</span>Note that it is vital that the bytes are interpreted as UNSIGNED values in the range 0-255, or the wrong outcome may result.</div>
<div class="clause" id="s8.2_p8_c2"><span class="label">s8.2_p8_c2</span>In the example above, if the byte with value 200 had been incorrectly interpreted as a signed eight-bit value, then it would be interpreted as value -56, and the wrong address record would be deemed the winner.</div>
</div>

<h2 id="s8.2.1">8.2.1 Simultaneous Probe Tiebreaking for Multiple Records</h2>

<a name="s8.2.1" /><div class="paragraph" id="s8.2.1_p1">
<div class="clause" id="s8.2.1_p1_c1"><span class="label">s8.2.1_p1_c1</span>When a host is probing for a set of records with the same name, or a message is received containing multiple tiebreaker records answering a given probe question in the Question Section, the host's records and the tiebreaker records from the message are each sorted into order, and then compared pairwise, using the same comparison technique described above, until a difference is found.</div>
</div>

<div class="paragraph" id="s8.2.1_p2">
<div class="clause" id="s8.2.1_p2_c1"><span class="label">s8.2.1_p2_c1</span>The records are sorted using the same lexicographical order as described above, that is, if the record classes differ, the record with the lower class number comes first.</div>
<div class="clause" id="s8.2.1_p2_c2"><span class="label">s8.2.1_p2_c2</span>If the classes are the same but the rrtypes differ, the record with the lower rrtype number comes first.</div>
<div class="clause" id="s8.2.1_p2_c3"><span class="label">s8.2.1_p2_c3</span>If the class and rrtype match, then the rdata is compared bytewise until a difference is found.</div>
<div class="clause" id="s8.2.1_p2_c4"><span class="label">s8.2.1_p2_c4</span>For example, in the common case of advertising DNS-SD services with a TXT record and an SRV record, the TXT record comes first (the rrtype value for TXT is 16) and the SRV record comes second (the rrtype value for SRV is 33).</div>
</div>

<div class="paragraph" id="s8.2.1_p3">
<div class="clause" id="s8.2.1_p3_c1"><span class="label">s8.2.1_p3_c1</span>When comparing the records, if the first records match perfectly, then the second records are compared, and so on.</div>
<div class="clause" id="s8.2.1_p3_c2"><span class="label">s8.2.1_p3_c2</span>If either list of records runs out of records before any difference is found, then the list with records remaining is deemed to have won the tiebreak.</div>
<div class="clause" id="s8.2.1_p3_c3"><span class="label">s8.2.1_p3_c3</span>If both lists run out of records at the same time without any difference being found, then this indicates that two devices are advertising identical sets of records, as is sometimes done for fault tolerance, and there is, in fact, no conflict.</div>
</div>

<h2 id="s8.3">8.3 Announcing</h2>

<a name="s8.3" /><div class="paragraph" id="s8.3_p1">
<div class="clause must" id="s8.3_p1_c1"><span class="label">s8.3_p1_c1</span>The second startup step is that the Multicast DNS responder MUST send an unsolicited Multicast DNS response containing, in the Answer Section, all of its newly registered resource records (both shared records, and unique records that have completed the probing step).</div>
<div class="clause" id="s8.3_p1_c2"><span class="label">s8.3_p1_c2</span>If there are too many resource records to fit in a single packet, multiple packets should be used.</div>
</div>

<div class="paragraph" id="s8.3_p2">
<div class="clause" id="s8.3_p2_c1"><span class="label">s8.3_p2_c1</span>In the case of shared records (e.g., the PTR records used by DNS- Based Service Discovery [RFC6763]), the records are simply placed as is into the Answer Section of the DNS response.</div>
</div>

<div class="paragraph" id="s8.3_p3">
<div class="clause" id="s8.3_p3_c1"><span class="label">s8.3_p3_c1</span>In the case of records that have been verified to be unique in the previous step, they are placed into the Answer Section of the DNS response with the most significant bit of the rrclass set to one.</div>
<div class="clause" id="s8.3_p3_c2"><span class="label">s8.3_p3_c2</span>The most significant bit of the rrclass for a record in the Answer Section of a response message is the Multicast DNS cache-flush bit and is discussed in more detail below in Section 10.2, "Announcements to Flush Outdated Cache Entries".</div>
</div>

<div class="paragraph" id="s8.3_p4">
<div class="clause must" id="s8.3_p4_c1"><span class="label">s8.3_p4_c1</span>The Multicast DNS responder MUST send at least two unsolicited responses, one second apart.</div>
<div class="clause may" id="s8.3_p4_c2"><span class="label">s8.3_p4_c2</span>To provide increased robustness against packet loss, a responder MAY send up to eight unsolicited responses, provided that the interval between unsolicited responses increases by at least a factor of two with every response sent.</div>
</div>

<div class="paragraph" id="s8.3_p5">
<div class="clause must" id="s8.3_p5_c1"><span class="label">s8.3_p5_c1</span>A Multicast DNS responder MUST NOT send announcements in the absence of information that its network connectivity may have changed in some relevant way.</div>
<div class="clause must" id="s8.3_p5_c2"><span class="label">s8.3_p5_c2</span>In particular, a Multicast DNS responder MUST NOT send regular periodic announcements as a matter of course.</div>
</div>

<div class="paragraph" id="s8.3_p6">
<div class="clause must" id="s8.3_p6_c1"><span class="label">s8.3_p6_c1</span>Whenever a Multicast DNS responder receives any Multicast DNS response (solicited or otherwise) containing a conflicting resource record, the conflict MUST be resolved as described in Section 9, "Conflict Resolution".</div>
</div>

<h2 id="s8.4">8.4 Updating</h2>

<a name="s8.4" /><div class="paragraph" id="s8.4_p1">
<div class="clause must" id="s8.4_p1_c1"><span class="label">s8.4_p1_c1</span>At any time, if the rdata of any of a host's Multicast DNS records changes, the host MUST repeat the Announcing step described above to update neighboring caches.</div>
<div class="clause must" id="s8.4_p1_c2"><span class="label">s8.4_p1_c2</span>For example, if any of a host's IP addresses change, it MUST re-announce those address records.</div>
<div class="clause" id="s8.4_p1_c3"><span class="label">s8.4_p1_c3</span>The host does not need to repeat the Probing step because it has already established unique ownership of that name.</div>
</div>

<div class="paragraph" id="s8.4_p2">
<div class="clause must" id="s8.4_p2_c1"><span class="label">s8.4_p2_c1</span>In the case of shared records, a host MUST send a "goodbye" announcement with RR TTL zero (see Section 10.1, "Goodbye Packets") for the old rdata, to cause it to be deleted from peer caches, before announcing the new rdata.</div>
<div class="clause should" id="s8.4_p2_c2"><span class="label">s8.4_p2_c2</span>In the case of unique records, a host SHOULD omit the "goodbye" announcement, since the cache-flush bit on the newly announced records will cause old rdata to be flushed from peer caches anyway.</div>
</div>

<div class="paragraph" id="s8.4_p3">
<div class="clause should" id="s8.4_p3_c1"><span class="label">s8.4_p3_c1</span>A host may update the contents of any of its records at any time, though a host SHOULD NOT update records more frequently than ten times per minute.</div>
<div class="clause" id="s8.4_p3_c2"><span class="label">s8.4_p3_c2</span>Frequent rapid updates impose a burden on the network.</div>
<div class="clause" id="s8.4_p3_c3"><span class="label">s8.4_p3_c3</span>If a host has information to disseminate which changes more frequently than ten times per minute, then it may be more appropriate to design a protocol for that specific purpose.</div>
</div>

<h2 id="s9">9 Conflict Resolution</h2>

<a name="s9" /><div class="paragraph" id="s9_p1">
<div class="clause" id="s9_p1_c1"><span class="label">s9_p1_c1</span>A conflict occurs when a Multicast DNS responder has a unique record for which it is currently authoritative, and it receives a Multicast DNS response message containing a record with the same name, rrtype and rrclass, but inconsistent rdata.</div>
<div class="clause" id="s9_p1_c2"><span class="label">s9_p1_c2</span>What may be considered inconsistent is context sensitive, except that resource records with identical rdata are never considered inconsistent, even if they originate from different hosts.</div>
<div class="clause" id="s9_p1_c3"><span class="label">s9_p1_c3</span>This is to permit use of proxies and other fault-tolerance mechanisms that may cause more than one responder to be capable of issuing identical answers on the network.</div>
</div>

<div class="paragraph" id="s9_p2">
<div class="clause" id="s9_p2_c1"><span class="label">s9_p2_c1</span>A common example of a resource record type that is intended to be unique, not shared between hosts, is the address record that maps a host's name to its IP address.</div>
<div class="clause" id="s9_p2_c2"><span class="label">s9_p2_c2</span>Should a host witness another host announce an address record with the same name but a different IP address, then that is considered inconsistent, and that address record is considered to be in conflict.</div>
</div>

<div class="paragraph" id="s9_p3">
<div class="clause must" id="s9_p3_c1"><span class="label">s9_p3_c1</span>Whenever a Multicast DNS responder receives any Multicast DNS response (solicited or otherwise) containing a conflicting resource record in any of the Resource Record Sections, the Multicast DNS responder MUST immediately reset its conflicted unique record to probing state, and go through the startup steps described above in Section 8, "Probing and Announcing on Startup".</div>
<div class="clause must" id="s9_p3_c2"><span class="label">s9_p3_c2</span>The protocol used in the Probing phase will determine a winner and a loser, and the loser MUST cease using the name, and reconfigure.</div>
</div>

<div class="paragraph" id="s9_p4">
<div class="clause must" id="s9_p4_c1"><span class="label">s9_p4_c1</span>It is very important that any host receiving a resource record that conflicts with one of its own MUST take action as described above.</div>
<div class="clause" id="s9_p4_c2"><span class="label">s9_p4_c2</span>In the case of two hosts using the same host name, where one has been configured to require a unique host name and the other has not, the one that has not been configured to require a unique host name will not perceive any conflict, and will not take any action.</div>
<div class="clause" id="s9_p4_c3"><span class="label">s9_p4_c3</span>By reverting to Probing state, the host that desires a unique host name will go through the necessary steps to ensure that a unique host name is obtained.</div>
</div>

<div class="paragraph" id="s9_p5">
<div class="clause" id="s9_p5_c1"><span class="label">s9_p5_c1</span>The recommended course of action after probing and failing is as follows:</div>
</div>

<div class="paragraph" id="s9_p6">
<div class="clause" id="s9_p6_c1"><span class="label">s9_p6_c1</span>1. Programmatically change the resource record name in an attempt to find a new name that is unique.</div>
<div class="clause" id="s9_p6_c2"><span class="label">s9_p6_c2</span>This could be done by adding some further identifying information (e.g., the model name of the hardware) if it is not already present in the name, or appending the digit "2" to the name, or incrementing a number at the end of the name if one is already present.</div>
</div>

<div class="paragraph" id="s9_p7">
<div class="clause" id="s9_p7_c1"><span class="label">s9_p7_c1</span>2. Probe again, and repeat as necessary until a unique name is found.</div>
</div>

<div class="paragraph" id="s9_p8">
<div class="clause" id="s9_p8_c1"><span class="label">s9_p8_c1</span>3. Once an available unique name has been determined, by probing without receiving any conflicting response, record this newly chosen name in persistent storage so that the device will use the same name the next time it is power-cycled.</div>
</div>

<div class="paragraph" id="s9_p9">
<div class="clause" id="s9_p9_c1"><span class="label">s9_p9_c1</span>4. Display a message to the user or operator informing them of the name change.</div>
<div class="clause" id="s9_p9_c2"><span class="label">s9_p9_c2</span>For example:</div>
</div>

<div class="paragraph" id="s9_p10">
<div class="clause" id="s9_p10_c1"><span class="label">s9_p10_c1</span>The name "Bob's Music" is in use by another music server on the network.</div>
<div class="clause" id="s9_p10_c2"><span class="label">s9_p10_c2</span>Your music collection has been renamed to "Bob's Music (2)".</div>
<div class="clause" id="s9_p10_c3"><span class="label">s9_p10_c3</span>If you want to change this name, use [describe appropriate menu item or preference dialog here].</div>
</div>

<div class="paragraph" id="s9_p11">
<div class="clause" id="s9_p11_c1"><span class="label">s9_p11_c1</span>The details of how the user or operator is informed of the new name depends on context.</div>
<div class="clause" id="s9_p11_c2"><span class="label">s9_p11_c2</span>A desktop computer with a screen might put up a dialog box.</div>
<div class="clause" id="s9_p11_c3"><span class="label">s9_p11_c3</span>A headless server in the closet may write a message to a log file, or use whatever mechanism (email, SNMP trap, etc.)</div>
<div class="clause" id="s9_p11_c4"><span class="label">s9_p11_c4</span>it uses to inform the administrator of error conditions.</div>
<div class="clause" id="s9_p11_c5"><span class="label">s9_p11_c5</span>On the other hand, a headless server in the closet may not inform the user at all -- if the user cares, they will notice the name has changed, and connect to the server in the usual way (e.g., via web browser) to configure a new name.</div>
</div>

<div class="paragraph" id="s9_p12">
<div class="clause" id="s9_p12_c1"><span class="label">s9_p12_c1</span>5. After one minute of probing, if the Multicast DNS responder has been unable to find any unused name, it should log an error message to inform the user or operator of this fact.</div>
<div class="clause" id="s9_p12_c2"><span class="label">s9_p12_c2</span>This situation should never occur in normal operation.</div>
<div class="clause" id="s9_p12_c3"><span class="label">s9_p12_c3</span>The only situations that would cause this to happen would be either a deliberate denial-of-service attack, or some kind of very obscure hardware or software bug that acts like a deliberate denial-of-service attack.</div>
</div>

<div class="paragraph" id="s9_p13">
<div class="clause" id="s9_p13_c1"><span class="label">s9_p13_c1</span>These considerations apply to address records (i.e., host names) and to all resource records where uniqueness (or maintenance of some other defined constraint) is desired.</div>
</div>

<h2 id="s10">10 Resource Record TTL Values and Cache Coherency</h2>

<a name="s10" /><div class="paragraph" id="s10_p1">
<div class="clause should" id="s10_p1_c1"><span class="label">s10_p1_c1</span>As a general rule, the recommended TTL value for Multicast DNS resource records with a host name as the resource record's name (e.g., A, AAAA, HINFO) or a host name contained within the resource record's rdata (e.g., SRV, reverse mapping PTR record) SHOULD be 120 seconds.</div>
</div>

<div class="paragraph" id="s10_p2">
<div class="clause" id="s10_p2_c1"><span class="label">s10_p2_c1</span>The recommended TTL value for other Multicast DNS resource records is 75 minutes.</div>
</div>

<div class="paragraph" id="s10_p3">
<div class="clause" id="s10_p3_c1"><span class="label">s10_p3_c1</span>A querier with an active outstanding query will issue a query message when one or more of the resource records in its cache are 80% of the way to expiry.</div>
<div class="clause" id="s10_p3_c2"><span class="label">s10_p3_c2</span>If the TTL on those records is 75 minutes, this ongoing cache maintenance process yields a steady-state query rate of one query every 60 minutes.</div>
</div>

<div class="paragraph" id="s10_p4">
<div class="clause" id="s10_p4_c1"><span class="label">s10_p4_c1</span>Any distributed cache needs a cache coherency protocol.</div>
<div class="clause" id="s10_p4_c2"><span class="label">s10_p4_c2</span>If Multicast DNS resource records follow the recommendation and have a TTL of 75 minutes, that means that stale data could persist in the system for a little over an hour.</div>
<div class="clause" id="s10_p4_c3"><span class="label">s10_p4_c3</span>Making the default RR TTL significantly lower would reduce the lifetime of stale data, but would produce too much extra traffic on the network.</div>
<div class="clause" id="s10_p4_c4"><span class="label">s10_p4_c4</span>Various techniques are available to minimize the impact of such stale data, outlined in the five subsections below.</div>
</div>

<h2 id="s10.1">10.1 Goodbye Packets</h2>

<a name="s10.1" /><div class="paragraph" id="s10.1_p1">
<div class="clause should" id="s10.1_p1_c1"><span class="label">s10.1_p1_c1</span>In the case where a host knows that certain resource record data is about to become invalid (for example, when the host is undergoing a clean shutdown), the host SHOULD send an unsolicited Multicast DNS response packet, giving the same resource record name, rrtype, rrclass, and rdata, but an RR TTL of zero.</div>
<div class="clause" id="s10.1_p1_c2"><span class="label">s10.1_p1_c2</span>This has the effect of updating the TTL stored in neighboring hosts' cache entries to zero, causing that cache entry to be promptly deleted.</div>
</div>

<div class="paragraph" id="s10.1_p2">
<div class="clause should" id="s10.1_p2_c1"><span class="label">s10.1_p2_c1</span>Queriers receiving a Multicast DNS response with a TTL of zero SHOULD NOT immediately delete the record from the cache, but instead record a TTL of 1 and then delete the record one second later.</div>
<div class="clause" id="s10.1_p2_c2"><span class="label">s10.1_p2_c2</span>In the case of multiple Multicast DNS responders on the network described in Section 6.6 above, if one of the responders shuts down and incorrectly sends goodbye packets for its records, it gives the other cooperating responders one second to send out their own response to "rescue" the records before they expire and are deleted.</div>
</div>

<h2 id="s10.2">10.2 Announcements to Flush Outdated Cache Entries</h2>

<a name="s10.2" /><div class="paragraph" id="s10.2_p1">
<div class="clause" id="s10.2_p1_c1"><span class="label">s10.2_p1_c1</span>Whenever a host has a resource record with new data, or with what might potentially be new data (e.g., after rebooting, waking from sleep, connecting to a new network link, or changing IP address), the host needs to inform peers of that new data.</div>
<div class="clause must" id="s10.2_p1_c2"><span class="label">s10.2_p1_c2</span>In cases where the host has not been continuously connected and participating on the network link, it MUST first probe to re-verify uniqueness of its unique records, as described above in Section 8.1, "Probing".</div>
</div>

<div class="paragraph" id="s10.2_p2">
<div class="clause must" id="s10.2_p2_c1"><span class="label">s10.2_p2_c1</span>Having completed the Probing step, if necessary, the host MUST then send a series of unsolicited announcements to update cache entries in its neighbor hosts.</div>
<div class="clause" id="s10.2_p2_c2"><span class="label">s10.2_p2_c2</span>In these unsolicited announcements, if the record is one that has been verified unique, the host sets the most significant bit of the rrclass field of the resource record.</div>
<div class="clause" id="s10.2_p2_c3"><span class="label">s10.2_p2_c3</span>This bit, the cache-flush bit, tells neighboring hosts that this is not a shared record type.</div>
<div class="clause" id="s10.2_p2_c4"><span class="label">s10.2_p2_c4</span>Instead of merging this new record additively into the cache in addition to any previous records with the same name, rrtype, and rrclass, all old records with that name, rrtype, and rrclass that were received more than one second ago are declared invalid, and marked to expire from the cache in one second.</div>
</div>

<div class="paragraph" id="s10.2_p3">
<div class="clause" id="s10.2_p3_c1"><span class="label">s10.2_p3_c1</span>The semantics of the cache-flush bit are as follows: normally when a resource record appears in a Resource Record Section of the DNS response it means, "This is an assertion that this information is true".</div>
<div class="clause" id="s10.2_p3_c2"><span class="label">s10.2_p3_c2</span>When a resource record appears in a Resource Record Section of the DNS response with the cache-flush bit set, it means, "This is an assertion that this information is the truth and the whole truth, and anything you may have heard more than a second ago regarding records of this name/rrtype/rrclass is no longer true".</div>
</div>

<div class="paragraph" id="s10.2_p4">
<div class="clause" id="s10.2_p4_c1"><span class="label">s10.2_p4_c1</span>To accommodate the case where the set of records from one host constituting a single unique RRSet is too large to fit in a single packet, only cache records that are more than one second old are flushed.</div>
<div class="clause" id="s10.2_p4_c2"><span class="label">s10.2_p4_c2</span>This allows the announcing host to generate a quick burst of packets back-to-back on the wire containing all the members of the RRSet.</div>
<div class="clause" id="s10.2_p4_c3"><span class="label">s10.2_p4_c3</span>When receiving records with the cache-flush bit set, all records older than one second are marked to be deleted one second in the future.</div>
<div class="clause" id="s10.2_p4_c4"><span class="label">s10.2_p4_c4</span>One second after the end of the little packet burst, any records not represented within that packet burst will then be expired from all peer caches.</div>
</div>

<div class="paragraph" id="s10.2_p5">
<div class="clause must" id="s10.2_p5_c1"><span class="label">s10.2_p5_c1</span>Any time a host sends a response packet containing some members of a unique RRSet, it MUST send the entire RRSet, preferably in a single packet, or if the entire RRSet will not fit in a single packet, in a quick burst of packets sent as close together as possible.</div>
<div class="clause must" id="s10.2_p5_c2"><span class="label">s10.2_p5_c2</span>The host MUST set the cache-flush bit on all members of the unique RRSet.</div>
</div>

<div class="paragraph" id="s10.2_p6">
<div class="clause" id="s10.2_p6_c1"><span class="label">s10.2_p6_c1</span>Another reason for waiting one second before deleting stale records from the cache is to accommodate bridged networks.</div>
<div class="clause" id="s10.2_p6_c2"><span class="label">s10.2_p6_c2</span>For example, a host's address record announcement on a wireless interface may be bridged onto a wired Ethernet and may cause that same host's Ethernet address records to be flushed from peer caches.</div>
<div class="clause" id="s10.2_p6_c3"><span class="label">s10.2_p6_c3</span>The one-second delay gives the host the chance to see its own announcement arrive on the wired Ethernet, and immediately re-announce its Ethernet interface's address records so that both sets remain valid and live in peer caches.</div>
</div>

<div class="paragraph" id="s10.2_p7">
<div class="clause" id="s10.2_p7_c1"><span class="label">s10.2_p7_c1</span>These rules, about when to set the cache-flush bit and about sending the entire rrset, apply regardless of *why* the response message is being generated.</div>
<div class="clause" id="s10.2_p7_c2"><span class="label">s10.2_p7_c2</span>They apply to startup announcements as described in Section 8.3, "Announcing", and to responses generated as a result of receiving query messages.</div>
</div>

<div class="paragraph" id="s10.2_p8">
<div class="clause" id="s10.2_p8_c1"><span class="label">s10.2_p8_c1</span>The cache-flush bit is only set in records in the Resource Record Sections of Multicast DNS responses sent to UDP port 5353.</div>
</div>

<div class="paragraph" id="s10.2_p9">
<div class="clause must" id="s10.2_p9_c1"><span class="label">s10.2_p9_c1</span>The cache-flush bit MUST NOT be set in any resource records in a response message sent in legacy unicast responses to UDP ports other than 5353.</div>
</div>

<div class="paragraph" id="s10.2_p10">
<div class="clause must" id="s10.2_p10_c1"><span class="label">s10.2_p10_c1</span>The cache-flush bit MUST NOT be set in any resource records in the Known-Answer list of any query message.</div>
</div>

<div class="paragraph" id="s10.2_p11">
<div class="clause must" id="s10.2_p11_c1"><span class="label">s10.2_p11_c1</span>The cache-flush bit MUST NOT ever be set in any shared resource record.</div>
<div class="clause" id="s10.2_p11_c2"><span class="label">s10.2_p11_c2</span>To do so would cause all the other shared versions of this resource record with different rdata from different responders to be immediately deleted from all the caches on the network.</div>
</div>

<div class="paragraph" id="s10.2_p12">
<div class="clause" id="s10.2_p12_c1"><span class="label">s10.2_p12_c1</span>The cache-flush bit does *not* apply to questions listed in the Question Section of a Multicast DNS message.</div>
<div class="clause" id="s10.2_p12_c2"><span class="label">s10.2_p12_c2</span>The top bit of the rrclass field in questions is used for an entirely different purpose (see Section 5.4, "Questions Requesting Unicast Responses").</div>
</div>

<div class="paragraph" id="s10.2_p13">
<div class="clause" id="s10.2_p13_c1"><span class="label">s10.2_p13_c1</span>Note that the cache-flush bit is NOT part of the resource record class.</div>
<div class="clause" id="s10.2_p13_c2"><span class="label">s10.2_p13_c2</span>The cache-flush bit is the most significant bit of the second 16-bit word of a resource record in a Resource Record Section of a Multicast DNS message (the field conventionally referred to as the rrclass field), and the actual resource record class is the least significant fifteen bits of this field.</div>
<div class="clause" id="s10.2_p13_c3"><span class="label">s10.2_p13_c3</span>There is no Multicast DNS resource record class 0x8001.</div>
<div class="clause" id="s10.2_p13_c4"><span class="label">s10.2_p13_c4</span>The value 0x8001 in the rrclass field of a resource record in a Multicast DNS response message indicates a resource record with class 1, with the cache-flush bit set.</div>
<div class="clause" id="s10.2_p13_c5"><span class="label">s10.2_p13_c5</span>When receiving a resource record with the cache-flush bit set, implementations should take care to mask off that bit before storing the resource record in memory, or otherwise ensure that it is given the correct semantic interpretation.</div>
</div>

<div class="paragraph" id="s10.2_p14">
<div class="clause" id="s10.2_p14_c1"><span class="label">s10.2_p14_c1</span>The reuse of the top bit of the rrclass field only applies to conventional resource record types that are subject to caching, not to pseudo-RRs like OPT [RFC2671], TSIG [RFC2845], TKEY [RFC2930], SIG0 [RFC2931], etc., that pertain only to a particular transport level message and not to any actual DNS data.</div>
<div class="clause" id="s10.2_p14_c2"><span class="label">s10.2_p14_c2</span>Since pseudo-RRs should never go into the Multicast DNS cache, the concept of a cache- flush bit for these types is not applicable.</div>
<div class="clause" id="s10.2_p14_c3"><span class="label">s10.2_p14_c3</span>In particular, the rrclass field of an OPT record encodes the sender's UDP payload size, and should be interpreted as a sixteen-bit length value in the range 0-65535, not a one-bit flag and a fifteen-bit length.</div>
</div>

<h2 id="s10.3">10.3 Cache Flush on Topology change</h2>

<a name="s10.3" /><div class="paragraph" id="s10.3_p1">
<div class="clause" id="s10.3_p1_c1"><span class="label">s10.3_p1_c1</span>If the hardware on a given host is able to indicate physical changes of connectivity, then when the hardware indicates such a change, the host should take this information into account in its Multicast DNS cache management strategy.</div>
<div class="clause" id="s10.3_p1_c2"><span class="label">s10.3_p1_c2</span>For example, a host may choose to immediately flush all cache records received on a particular interface when that cable is disconnected.</div>
<div class="clause" id="s10.3_p1_c3"><span class="label">s10.3_p1_c3</span>Alternatively, a host may choose to adjust the remaining TTL on all those records to a few seconds so that if the cable is not reconnected quickly, those records will expire from the cache.</div>
</div>

<div class="paragraph" id="s10.3_p2">
<div class="clause" id="s10.3_p2_c1"><span class="label">s10.3_p2_c1</span>Likewise, when a host reboots, wakes from sleep, or undergoes some other similar discontinuous state change, the cache management strategy should take that information into account.</div>
</div>

<h2 id="s10.4">10.4 Cache Flush on Failure Indication</h2>

<a name="s10.4" /><div class="paragraph" id="s10.4_p1">
<div class="clause" id="s10.4_p1_c1"><span class="label">s10.4_p1_c1</span>Sometimes a cache record can be determined to be stale when a client attempts to use the rdata it contains, and the client finds that rdata to be incorrect.</div>
</div>

<div class="paragraph" id="s10.4_p2">
<div class="clause" id="s10.4_p2_c1"><span class="label">s10.4_p2_c1</span>For example, the rdata in an address record can be determined to be incorrect if attempts to contact that host fail, either because (for an IPv4 address on a local subnet) ARP requests for that address go unanswered, because (for an IPv6 address with an on-link prefix) ND requests for that address go unanswered, or because (for an address on a remote network) a router returns an ICMP "Host Unreachable" error.</div>
</div>

<div class="paragraph" id="s10.4_p3">
<div class="clause" id="s10.4_p3_c1"><span class="label">s10.4_p3_c1</span>The rdata in an SRV record can be determined to be incorrect if attempts to communicate with the indicated service at the host and port number indicated are not successful.</div>
</div>

<div class="paragraph" id="s10.4_p4">
<div class="clause" id="s10.4_p4_c1"><span class="label">s10.4_p4_c1</span>The rdata in a DNS-SD PTR record can be determined to be incorrect if attempts to look up the SRV record it references are not successful.</div>
</div>

<div class="paragraph" id="s10.4_p5">
<div class="clause" id="s10.4_p5_c1"><span class="label">s10.4_p5_c1</span>The software implementing the Multicast DNS resource record cache should provide a mechanism so that clients detecting stale rdata can inform the cache.</div>
</div>

<div class="paragraph" id="s10.4_p6">
<div class="clause must" id="s10.4_p6_c1"><span class="label">s10.4_p6_c1</span>When the cache receives this hint that it should reconfirm some record, it MUST issue two or more queries for the resource record in dispute.</div>
<div class="clause should" id="s10.4_p6_c2"><span class="label">s10.4_p6_c2</span>If no response is received within ten seconds, then, even though its TTL may indicate that it is not yet due to expire, that record SHOULD be promptly flushed from the cache.</div>
</div>

<div class="paragraph" id="s10.4_p7">
<div class="clause" id="s10.4_p7_c1"><span class="label">s10.4_p7_c1</span>The end result of this is that if a printer suffers a sudden power failure or other abrupt disconnection from the network, its name may continue to appear in DNS-SD browser lists displayed on users' screens.</div>
<div class="clause" id="s10.4_p7_c2"><span class="label">s10.4_p7_c2</span>Eventually, that entry will expire from the cache naturally, but if a user tries to access the printer before that happens, the failure to successfully contact the printer will trigger the more hasty demise of its cache entries.</div>
<div class="clause" id="s10.4_p7_c3"><span class="label">s10.4_p7_c3</span>This is a sensible trade-off between good user experience and good network efficiency.</div>
<div class="clause" id="s10.4_p7_c4"><span class="label">s10.4_p7_c4</span>If we were to insist that printers should disappear from the printer list within 30 seconds of becoming unavailable, for all failure modes, the only way to achieve this would be for the client to poll the printer at least every 30 seconds, or for the printer to announce its presence at least every 30 seconds, both of which would be an unreasonable burden on most networks.</div>
</div>

<h2 id="s10.5">10.5 Passive Observation Of Failures (POOF)</h2>

<a name="s10.5" /><div class="paragraph" id="s10.5_p1">
<div class="clause" id="s10.5_p1_c1"><span class="label">s10.5_p1_c1</span>A host observes the multicast queries issued by the other hosts on the network.</div>
<div class="clause" id="s10.5_p1_c2"><span class="label">s10.5_p1_c2</span>One of the major benefits of also sending responses using multicast is that it allows all hosts to see the responses (or lack thereof) to those queries.</div>
</div>

<div class="paragraph" id="s10.5_p2">
<div class="clause" id="s10.5_p2_c1"><span class="label">s10.5_p2_c1</span>If a host sees queries, for which a record in its cache would be expected to be given as an answer in a multicast response, but no such answer is seen, then the host may take this as an indication that the record may no longer be valid.</div>
</div>

<div class="paragraph" id="s10.5_p3">
<div class="clause should" id="s10.5_p3_c1"><span class="label">s10.5_p3_c1</span>After seeing two or more of these queries, and seeing no multicast response containing the expected answer within ten seconds, then even though its TTL may indicate that it is not yet due to expire, that record SHOULD be flushed from the cache.</div>
<div class="clause should" id="s10.5_p3_c2"><span class="label">s10.5_p3_c2</span>The host SHOULD NOT perform its own queries to reconfirm that the record is truly gone.</div>
<div class="clause" id="s10.5_p3_c3"><span class="label">s10.5_p3_c3</span>If every host on a large network were to do this, it would cause a lot of unnecessary multicast traffic.</div>
<div class="clause" id="s10.5_p3_c4"><span class="label">s10.5_p3_c4</span>If host A sends multicast queries that remain unanswered, then there is no reason to suppose that host B or any other host is likely to be any more successful.</div>
</div>

<div class="paragraph" id="s10.5_p4">
<div class="clause" id="s10.5_p4_c1"><span class="label">s10.5_p4_c1</span>The previous section, "Cache Flush on Failure Indication", describes a situation where a user trying to print discovers that the printer is no longer available.</div>
<div class="clause" id="s10.5_p4_c2"><span class="label">s10.5_p4_c2</span>By implementing the passive observation described here, when one user fails to contact the printer, all hosts on the network observe that failure and update their caches accordingly.</div>
</div>

<h2 id="s11">11 Source Address Check</h2>

<a name="s11" /><div class="paragraph" id="s11_p1">
<div class="clause should" id="s11_p1_c1"><span class="label">s11_p1_c1</span>All Multicast DNS responses (including responses sent via unicast) SHOULD be sent with IP TTL set to 255.</div>
<div class="clause" id="s11_p1_c2"><span class="label">s11_p1_c2</span>This is recommended to provide backwards-compatibility with older Multicast DNS queriers (implementing a draft version of this document, posted in February 2004) that check the IP TTL on reception to determine whether the packet originated on the local link.</div>
<div class="clause" id="s11_p1_c3"><span class="label">s11_p1_c3</span>These older queriers discard all packets with TTLs other than 255.</div>
</div>

<div class="paragraph" id="s11_p2">
<div class="clause must" id="s11_p2_c1"><span class="label">s11_p2_c1</span>A host sending Multicast DNS queries to a link-local destination address (including the 224.0.0.251 and FF02::FB link-local multicast addresses) MUST only accept responses to that query that originate from the local link, and silently discard any other response packets.</div>
<div class="clause" id="s11_p2_c2"><span class="label">s11_p2_c2</span>Without this check, it could be possible for remote rogue hosts to send spoof answer packets (perhaps unicast to the victim host), which the receiving machine could misinterpret as having originated on the local link.</div>
</div>

<div class="paragraph" id="s11_p3">
<div class="clause" id="s11_p3_c1"><span class="label">s11_p3_c1</span>The test for whether a response originated on the local link is done in two ways:</div>
</div>

<div class="paragraph" id="s11_p4">
<div class="clause" id="s11_p4_c1"><span class="label">s11_p4_c1</span>* All responses received with a destination address in the IP header that is the mDNS IPv4 link-local multicast address 224.0.0.251 or the mDNS IPv6 link-local multicast address FF02::FB are necessarily deemed to have originated on the local link, regardless of source IP address.</div>
<div class="clause" id="s11_p4_c2"><span class="label">s11_p4_c2</span>This is essential to allow devices to work correctly and reliably in unusual configurations, such as multiple logical IP subnets overlayed on a single link, or in cases of severe misconfiguration, where devices are physically connected to the same link, but are currently misconfigured with completely unrelated IP addresses and subnet masks.</div>
</div>

<div class="paragraph" id="s11_p5">
<div class="clause" id="s11_p5_c1"><span class="label">s11_p5_c1</span>* For responses received with a unicast destination address in the IP header, the source IP address in the packet is checked to see if it is an address on a local subnet.</div>
<div class="clause" id="s11_p5_c2"><span class="label">s11_p5_c2</span>An IPv4 source address is determined to be on a local subnet if, for (one of) the address(es) configured on the interface receiving the packet, (I &amp; M) == (P &amp; M), where I and M are the interface address and subnet mask respectively, P is the source IP address from the packet, '&amp;' represents the bitwise logical 'and' operation, and '==' represents a bitwise equality test.</div>
<div class="clause" id="s11_p5_c3"><span class="label">s11_p5_c3</span>An IPv6 source address is determined to be on the local link if, for any of the on-link IPv6 prefixes on the interface receiving the packet (learned via IPv6 router advertisements or otherwise configured on the host), the first 'n' bits of the IPv6 source address match the first 'n' bits of the prefix address, where 'n' is the length of the prefix being considered.</div>
</div>

<div class="paragraph" id="s11_p6">
<div class="clause should" id="s11_p6_c1"><span class="label">s11_p6_c1</span>Since queriers will ignore responses apparently originating outside the local subnet, a responder SHOULD avoid generating responses that it can reasonably predict will be ignored.</div>
<div class="clause" id="s11_p6_c2"><span class="label">s11_p6_c2</span>This applies particularly in the case of overlayed subnets.</div>
<div class="clause should" id="s11_p6_c3"><span class="label">s11_p6_c3</span>If a responder receives a query addressed to the mDNS IPv4 link-local multicast address 224.0.0.251, from a source address not apparently on the same subnet as the responder (or, in the case of IPv6, from a source IPv6 address for which the responder does not have any address with the same prefix on that interface), then even if the query indicates that a unicast response is preferred (see Section 5.4, "Questions Requesting Unicast Responses"), the responder SHOULD elect to respond by multicast anyway, since it can reasonably predict that a unicast response with an apparently non-local source address will probably be ignored.</div>
</div>

<h2 id="s12">12 Special Characteristics of Multicast DNS Domains</h2>

<a name="s12" /><div class="paragraph" id="s12_p1">
<div class="clause" id="s12_p1_c1"><span class="label">s12_p1_c1</span>Unlike conventional DNS names, names that end in ".local." have only local significance.</div>
<div class="clause" id="s12_p1_c2"><span class="label">s12_p1_c2</span>The same is true of names within the IPv4 link- local reverse mapping domain "254.169.in-addr.arpa." and the IPv6 link-local reverse mapping domains "8.e.f.ip6.arpa.", "9.e.f.ip6.arpa.", "a.e.f.ip6.arpa.", and "b.e.f.ip6.arpa.".</div>
</div>

<div class="paragraph" id="s12_p2">
<div class="clause" id="s12_p2_c1"><span class="label">s12_p2_c1</span>These names function primarily as protocol identifiers, rather than as user-visible identifiers.</div>
<div class="clause" id="s12_p2_c2"><span class="label">s12_p2_c2</span>Even though they may occasionally be visible to end users, that is not their primary purpose.</div>
<div class="clause" id="s12_p2_c3"><span class="label">s12_p2_c3</span>As such, these names should be treated as opaque identifiers.</div>
<div class="clause" id="s12_p2_c4"><span class="label">s12_p2_c4</span>In particular, the string "local" should not be translated or localized into different languages, much as the name "localhost" is not translated or localized into different languages.</div>
</div>

<div class="paragraph" id="s12_p3">
<div class="clause" id="s12_p3_c1"><span class="label">s12_p3_c1</span>Conventional Unicast DNS seeks to provide a single unified namespace, where a given DNS query yields the same answer no matter where on the planet it is performed or to which recursive DNS server the query is sent.</div>
<div class="clause" id="s12_p3_c2"><span class="label">s12_p3_c2</span>In contrast, each IP link has its own private ".local.", "254.169.in-addr.arpa." and IPv6 link-local reverse mapping namespaces, and the answer to any query for a name within those domains depends on where that query is asked.</div>
<div class="clause" id="s12_p3_c3"><span class="label">s12_p3_c3</span>(This characteristic is not unique to Multicast DNS.</div>
<div class="clause" id="s12_p3_c4"><span class="label">s12_p3_c4</span>Although the original concept of DNS was a single global namespace, in recent years, split views, firewalls, intranets, DNS geolocation, and the like have increasingly meant that the answer to a given DNS query has become dependent on the location of the querier.)</div>
</div>

<div class="paragraph" id="s12_p4">
<div class="clause" id="s12_p4_c1"><span class="label">s12_p4_c1</span>The IPv4 name server address for a Multicast DNS domain is 224.0.0.251.</div>
<div class="clause" id="s12_p4_c2"><span class="label">s12_p4_c2</span>The IPv6 name server address for a Multicast DNS domain is FF02::FB.</div>
<div class="clause" id="s12_p4_c3"><span class="label">s12_p4_c3</span>These are multicast addresses; therefore, they identify not a single host but a collection of hosts, working in cooperation to maintain some reasonable facsimile of a competently managed DNS zone.</div>
<div class="clause" id="s12_p4_c4"><span class="label">s12_p4_c4</span>Conceptually, a Multicast DNS domain is a single DNS zone; however, its server is implemented as a distributed process running on a cluster of loosely cooperating CPUs rather than as a single process running on a single CPU.</div>
</div>

<div class="paragraph" id="s12_p5">
<div class="clause" id="s12_p5_c1"><span class="label">s12_p5_c1</span>Multicast DNS domains are not delegated from their parent domain via use of NS (Name Server) records, and there is also no concept of delegation of subdomains within a Multicast DNS domain.</div>
<div class="clause" id="s12_p5_c2"><span class="label">s12_p5_c2</span>Just because a particular host on the network may answer queries for a particular record type with the name "example.local." does not imply anything about whether that host will answer for the name "child.example.local.", or indeed for other record types with the name "example.local.".</div>
</div>

<div class="paragraph" id="s12_p6">
<div class="clause" id="s12_p6_c1"><span class="label">s12_p6_c1</span>There are no NS records anywhere in Multicast DNS domains.</div>
<div class="clause" id="s12_p6_c2"><span class="label">s12_p6_c2</span>Instead, the Multicast DNS domains are reserved by IANA, and there is effectively an implicit delegation of all Multicast DNS domains to the 224.0.0.251:5353 and [FF02::FB]:5353 multicast groups, by virtue of client software implementing the protocol rules specified in this document.</div>
</div>

<div class="paragraph" id="s12_p7">
<div class="clause" id="s12_p7_c1"><span class="label">s12_p7_c1</span>Multicast DNS zones have no SOA (Start of Authority) record.</div>
<div class="clause" id="s12_p7_c2"><span class="label">s12_p7_c2</span>A conventional DNS zone's SOA record contains information such as the email address of the zone administrator and the monotonically increasing serial number of the last zone modification.</div>
<div class="clause" id="s12_p7_c3"><span class="label">s12_p7_c3</span>There is no single human administrator for any given Multicast DNS zone, so there is no email address.</div>
<div class="clause" id="s12_p7_c4"><span class="label">s12_p7_c4</span>Because the hosts managing any given Multicast DNS zone are only loosely coordinated, there is no readily available monotonically increasing serial number to determine whether or not the zone contents have changed.</div>
<div class="clause" id="s12_p7_c5"><span class="label">s12_p7_c5</span>A host holding part of the shared zone could crash or be disconnected from the network at any time without informing the other hosts.</div>
<div class="clause" id="s12_p7_c6"><span class="label">s12_p7_c6</span>There is no reliable way to provide a zone serial number that would, whenever such a crash or disconnection occurred, immediately change to indicate that the contents of the shared zone had changed.</div>
</div>

<div class="paragraph" id="s12_p8">
<div class="clause" id="s12_p8_c1"><span class="label">s12_p8_c1</span>Zone transfers are not possible for any Multicast DNS zone.</div>
</div>

<h2 id="s13">13 Enabling and Disabling Multicast DNS</h2>

<a name="s13" /><div class="paragraph" id="s13_p1">
<div class="clause should" id="s13_p1_c1"><span class="label">s13_p1_c1</span>The option to fail-over to Multicast DNS for names not ending in ".local." SHOULD be a user-configured option, and SHOULD be disabled by default because of the possible security issues related to unintended local resolution of apparently global names.</div>
<div class="clause" id="s13_p1_c2"><span class="label">s13_p1_c2</span>Enabling Multicast DNS for names not ending in ".local." may be appropriate on a secure isolated network, or on some future network were machines exclusively use DNSSEC for all DNS queries, and have Multicast DNS responders capable of generating the appropriate cryptographic DNSSEC signatures, thereby guarding against spoofing.</div>
</div>

<div class="paragraph" id="s13_p2">
<div class="clause" id="s13_p2_c1"><span class="label">s13_p2_c1</span>The option to look up unqualified (relative) names by appending ".local." (or not) is controlled by whether ".local." appears (or not) in the client's DNS search list.</div>
</div>

<div class="paragraph" id="s13_p3">
<div class="clause" id="s13_p3_c1"><span class="label">s13_p3_c1</span>No special control is needed for enabling and disabling Multicast DNS for names explicitly ending with ".local." as entered by the user.</div>
<div class="clause" id="s13_p3_c2"><span class="label">s13_p3_c2</span>The user doesn't need a way to disable Multicast DNS for names ending with ".local.", because if the user doesn't want to use Multicast DNS, they can achieve this by simply not using those names.</div>
<div class="clause" id="s13_p3_c3"><span class="label">s13_p3_c3</span>If a user *does* enter a name ending in ".local.", then we can safely assume the user's intention was probably that it should work.</div>
<div class="clause" id="s13_p3_c4"><span class="label">s13_p3_c4</span>Having user configuration options that can be (intentionally or unintentionally) set so that local names don't work is just one more way of frustrating the user's ability to perform the tasks they want, perpetuating the view that, "IP networking is too complicated to configure and too hard to use".</div>
</div>

<h2 id="s14">14 Considerations for Multiple Interfaces</h2>

<a name="s14" /><div class="paragraph" id="s14_p1">
<div class="clause should" id="s14_p1_c1"><span class="label">s14_p1_c1</span>A host SHOULD defend its dot-local host name on all active interfaces on which it is answering Multicast DNS queries.</div>
</div>

<div class="paragraph" id="s14_p2">
<div class="clause" id="s14_p2_c1"><span class="label">s14_p2_c1</span>In the event of a name conflict on *any* interface, a host should configure a new host name, if it wishes to maintain uniqueness of its host name.</div>
</div>

<div class="paragraph" id="s14_p3">
<div class="clause" id="s14_p3_c1"><span class="label">s14_p3_c1</span>A host may choose to use the same name (or set of names) for all of its address records on all interfaces, or it may choose to manage its Multicast DNS interfaces independently, potentially answering to a different name (or set of names) on different interfaces.</div>
</div>

<div class="paragraph" id="s14_p4">
<div class="clause must" id="s14_p4_c1"><span class="label">s14_p4_c1</span>Except in the case of proxying and other similar specialized uses, addresses in IPv4 or IPv6 address records in Multicast DNS responses MUST be valid for use on the interface on which the response is being sent.</div>
</div>

<div class="paragraph" id="s14_p5">
<div class="clause" id="s14_p5_c1"><span class="label">s14_p5_c1</span>Just as the same link-local IP address may validly be in use simultaneously on different links by different hosts, the same link- local host name may validly be in use simultaneously on different links, and this is not an error.</div>
<div class="clause" id="s14_p5_c2"><span class="label">s14_p5_c2</span>A multihomed host with connections to two different links may be able to communicate with two different hosts that are validly using the same name.</div>
<div class="clause" id="s14_p5_c3"><span class="label">s14_p5_c3</span>While this kind of name duplication should be rare, it means that a host that wants to fully support this case needs network programming APIs that allow applications to specify on what interface to perform a link-local Multicast DNS query, and to discover on what interface a Multicast DNS response was received.</div>
</div>

<div class="paragraph" id="s14_p6">
<div class="clause" id="s14_p6_c1"><span class="label">s14_p6_c1</span>There is one other special precaution that multihomed hosts need to take.</div>
<div class="clause" id="s14_p6_c2"><span class="label">s14_p6_c2</span>It's common with today's laptop computers to have an Ethernet connection and an 802.11 [IEEE.802.11] wireless connection active at the same time.</div>
<div class="clause" id="s14_p6_c3"><span class="label">s14_p6_c3</span>What the software on the laptop computer can't easily tell is whether the wireless connection is in fact bridged onto the same network segment as its Ethernet connection.</div>
<div class="clause" id="s14_p6_c4"><span class="label">s14_p6_c4</span>If the two networks are bridged together, then packets the host sends on one interface will arrive on the other interface a few milliseconds later, and care must be taken to ensure that this bridging does not cause problems:</div>
</div>

<div class="paragraph" id="s14_p7">
<div class="clause" id="s14_p7_c1"><span class="label">s14_p7_c1</span>When the host announces its host name (i.e., its address records) on its wireless interface, those announcement records are sent with the cache-flush bit set, so when they arrive on the Ethernet segment, they will cause all the peers on the Ethernet to flush the host's Ethernet address records from their caches.</div>
<div class="clause" id="s14_p7_c2"><span class="label">s14_p7_c2</span>The Multicast DNS protocol has a safeguard to protect against this situation: when records are received with the cache-flush bit set, other records are not deleted from peer caches immediately, but are marked for deletion in one second.</div>
<div class="clause" id="s14_p7_c3"><span class="label">s14_p7_c3</span>When the host sees its own wireless address records arrive on its Ethernet interface, with the cache-flush bit set, this one-second grace period gives the host time to respond and re- announce its Ethernet address records, to reinstate those records in peer caches before they are deleted.</div>
</div>

<div class="paragraph" id="s14_p8">
<div class="clause" id="s14_p8_c1"><span class="label">s14_p8_c1</span>As described, this solves one problem, but creates another, because when those Ethernet announcement records arrive back on the wireless interface, the host would again respond defensively to reinstate its wireless records, and this process would continue forever, continuously flooding the network with traffic.</div>
<div class="clause" id="s14_p8_c2"><span class="label">s14_p8_c2</span>The Multicast DNS protocol has a second safeguard, to solve this problem: the cache- flush bit does not apply to records received very recently, within the last second.</div>
<div class="clause" id="s14_p8_c3"><span class="label">s14_p8_c3</span>This means that when the host sees its own Ethernet address records arrive on its wireless interface, with the cache- flush bit set, it knows there's no need to re-announce its wireless address records again because it already sent them less than a second ago, and this makes them immune from deletion from peer caches.</div>
<div class="clause" id="s14_p8_c4"><span class="label">s14_p8_c4</span>(See Section 10.2.)</div>
</div>

<h2 id="s15">15 Considerations for Multiple Responders on the Same Machine</h2>

<a name="s15" /><div class="paragraph" id="s15_p1">
<div class="clause" id="s15_p1_c1"><span class="label">s15_p1_c1</span>It is possible to have more than one Multicast DNS responder and/or querier implementation coexist on the same machine, but there are some known issues.</div>
</div>

<h2 id="s15.1">15.1 Receiving Unicast Responses</h2>

<a name="s15.1" /><div class="paragraph" id="s15.1_p1">
<div class="clause" id="s15.1_p1_c1"><span class="label">s15.1_p1_c1</span>In most operating systems, incoming *multicast* packets can be delivered to *all* open sockets bound to the right port number, provided that the clients take the appropriate steps to allow this.</div>
<div class="clause should" id="s15.1_p1_c2"><span class="label">s15.1_p1_c2</span>For this reason, all Multicast DNS implementations SHOULD use the SO_REUSEPORT and/or SO_REUSEADDR options (or equivalent as appropriate for the operating system in question) so they will all be able to bind to UDP port 5353 and receive incoming multicast packets addressed to that port.</div>
<div class="clause" id="s15.1_p1_c3"><span class="label">s15.1_p1_c3</span>However, unlike multicast packets, incoming unicast UDP packets are typically delivered only to the first socket to bind to that port.</div>
<div class="clause" id="s15.1_p1_c4"><span class="label">s15.1_p1_c4</span>This means that "QU" responses and other packets sent via unicast will be received only by the first Multicast DNS responder and/or querier on a system.</div>
<div class="clause" id="s15.1_p1_c5"><span class="label">s15.1_p1_c5</span>This limitation can be partially mitigated if Multicast DNS implementations detect when they are not the first to bind to port 5353, and in that case they do not request "QU" responses.</div>
<div class="clause" id="s15.1_p1_c6"><span class="label">s15.1_p1_c6</span>One way to detect if there is another Multicast DNS implementation already running is to attempt binding to port 5353 without using SO_REUSEPORT and/or SO_REUSEADDR, and if that fails it indicates that some other socket is already bound to this port.</div>
</div>

<h2 id="s15.2">15.2 Multipacket Known-Answer lists</h2>

<a name="s15.2" /><div class="paragraph" id="s15.2_p1">
<div class="clause" id="s15.2_p1_c1"><span class="label">s15.2_p1_c1</span>When a Multicast DNS querier issues a query with too many Known Answers to fit into a single packet, it divides the Known-Answer list into two or more packets.</div>
<div class="clause" id="s15.2_p1_c2"><span class="label">s15.2_p1_c2</span>Multicast DNS responders associate the initial truncated query with its continuation packets by examining the source IP address in each packet.</div>
<div class="clause" id="s15.2_p1_c3"><span class="label">s15.2_p1_c3</span>Since two independent Multicast DNS queriers running on the same machine will be sending packets with the same source IP address, from an outside perspective they appear to be a single entity.</div>
<div class="clause" id="s15.2_p1_c4"><span class="label">s15.2_p1_c4</span>If both queriers happened to send the same multipacket query at the same time, with different Known- Answer lists, then they could each end up suppressing answers that the other needs.</div>
</div>

<h2 id="s15.3">15.3 Efficiency</h2>

<a name="s15.3" /><div class="paragraph" id="s15.3_p1">
<div class="clause" id="s15.3_p1_c1"><span class="label">s15.3_p1_c1</span>If different clients on a machine were each to have their own independent Multicast DNS implementation, they would lose certain efficiency benefits.</div>
<div class="clause" id="s15.3_p1_c2"><span class="label">s15.3_p1_c2</span>Apart from the unnecessary code duplication, memory usage, and CPU load, the clients wouldn't get the benefit of a shared system-wide cache, and they would not be able to aggregate separate queries into single packets to reduce network traffic.</div>
</div>

<h2 id="s15.4">15.4 Recommendation</h2>

<a name="s15.4" /><div class="paragraph" id="s15.4_p1">
<div class="clause" id="s15.4_p1_c1"><span class="label">s15.4_p1_c1</span>Because of these issues, this document encourages implementers to design systems with a single Multicast DNS implementation that provides Multicast DNS services shared by all clients on that machine, much as most operating systems today have a single TCP implementation, which is shared between all clients on that machine.</div>
<div class="clause" id="s15.4_p1_c2"><span class="label">s15.4_p1_c2</span>Due to engineering constraints, there may be situations where embedding a "user-level" Multicast DNS implementation in the client application software is the most expedient solution, and while this will usually work in practice, implementers should be aware of the issues outlined in this section.</div>
</div>

<h2 id="s16">16 Multicast DNS Character Set</h2>

<a name="s16" /><div class="paragraph" id="s16_p1">
<div class="clause" id="s16_p1_c1"><span class="label">s16_p1_c1</span>Historically, Unicast DNS has been used with a very restricted set of characters.</div>
<div class="clause" id="s16_p1_c2"><span class="label">s16_p1_c2</span>Indeed, conventional DNS is usually limited to just twenty-six letters, ten digits and the hyphen character, not even allowing spaces or other punctuation.</div>
<div class="clause" id="s16_p1_c3"><span class="label">s16_p1_c3</span>Attempts to remedy this for Unicast DNS have been badly constrained by the perceived need to accommodate old buggy legacy DNS implementations.</div>
<div class="clause" id="s16_p1_c4"><span class="label">s16_p1_c4</span>In reality, the DNS specification itself actually imposes no limits on what characters may be used in names, and good DNS implementations handle any arbitrary eight-bit data without trouble.</div>
<div class="clause" id="s16_p1_c5"><span class="label">s16_p1_c5</span>"Clarifications to the DNS Specification" [RFC2181] directly discusses the subject of allowable character set in Section 11 ("Name syntax"), and explicitly states that DNS names may contain arbitrary eight-bit data.</div>
<div class="clause" id="s16_p1_c6"><span class="label">s16_p1_c6</span>However, the old rules for ARPANET host names back in the 1980s required host names to be just letters, digits, and hyphens [RFC1034], and since the predominant use of DNS is to store host address records, many have assumed that the DNS protocol itself suffers from the same limitation.</div>
<div class="clause" id="s16_p1_c7"><span class="label">s16_p1_c7</span>It might be accurate to say that there could be hypothetical bad implementations that do not handle eight-bit data correctly, but it would not be accurate to say that the protocol doesn't allow names containing eight-bit data.</div>
</div>

<div class="paragraph" id="s16_p2">
<div class="clause" id="s16_p2_c1"><span class="label">s16_p2_c1</span>Multicast DNS is a new protocol and doesn't (yet) have old buggy legacy implementations to constrain the design choices.</div>
<div class="clause must" id="s16_p2_c2"><span class="label">s16_p2_c2</span>Accordingly, it adopts the simple obvious elegant solution: all names in Multicast DNS MUST be encoded as precomposed UTF-8 [RFC3629] "Net-Unicode" [RFC5198] text.</div>
</div>

<div class="paragraph" id="s16_p3">
<div class="clause" id="s16_p3_c1"><span class="label">s16_p3_c1</span>Some users of 16-bit Unicode have taken to stuffing a "zero-width nonbreaking space" character (U+FEFF) at the start of each UTF-16 file, as a hint to identify whether the data is big-endian or little- endian, and calling it a "Byte Order Mark" (BOM).</div>
<div class="clause" id="s16_p3_c2"><span class="label">s16_p3_c2</span>Since there is only one possible byte order for UTF-8 data, a BOM is neither necessary nor permitted.</div>
<div class="clause must" id="s16_p3_c3"><span class="label">s16_p3_c3</span>Multicast DNS names MUST NOT contain a "Byte Order Mark".</div>
<div class="clause must" id="s16_p3_c4"><span class="label">s16_p3_c4</span>Any occurrence of the Unicode character U+FEFF at the start or anywhere else in a Multicast DNS name MUST be interpreted as being an actual intended part of the name, representing (just as for any other legal unicode value) an actual literal instance of that character (in this case a zero-width non- breaking space character).</div>
</div>

<div class="paragraph" id="s16_p4">
<div class="clause" id="s16_p4_c1"><span class="label">s16_p4_c1</span>For names that are restricted to US-ASCII [RFC0020] letters, digits, and hyphens, the UTF-8 encoding is identical to the US-ASCII encoding, so this is entirely compatible with existing host names.</div>
<div class="clause" id="s16_p4_c2"><span class="label">s16_p4_c2</span>For characters outside the US-ASCII range, UTF-8 encoding is used.</div>
</div>

<div class="paragraph" id="s16_p5">
<div class="clause must" id="s16_p5_c1"><span class="label">s16_p5_c1</span>Multicast DNS implementations MUST NOT use any other encodings apart from precomposed UTF-8 (US-ASCII being considered a compatible subset of UTF-8).</div>
<div class="clause" id="s16_p5_c2"><span class="label">s16_p5_c2</span>The reasons for selecting UTF-8 instead of Punycode [RFC3492] are discussed further in Appendix F.</div>
</div>

<div class="paragraph" id="s16_p6">
<div class="clause" id="s16_p6_c1"><span class="label">s16_p6_c1</span>The simple rules for case-insensitivity in Unicast DNS [RFC1034] [RFC1035] also apply in Multicast DNS; that is to say, in name comparisons, the lowercase letters "a" to "z" (0x61 to 0x7A) match their uppercase equivalents "A" to "Z" (0x41 to 0x5A).</div>
<div class="clause" id="s16_p6_c2"><span class="label">s16_p6_c2</span>Hence, if a querier issues a query for an address record with the name "myprinter.local.", then a responder having an address record with the name "MyPrinter.local." should issue a response.</div>
<div class="clause" id="s16_p6_c3"><span class="label">s16_p6_c3</span>No other automatic equivalences should be assumed.</div>
<div class="clause" id="s16_p6_c4"><span class="label">s16_p6_c4</span>In particular, all UTF-8 multibyte characters (codes 0x80 and higher) are compared by simple binary comparison of the raw byte values.</div>
<div class="clause" id="s16_p6_c5"><span class="label">s16_p6_c5</span>Accented characters are *not* defined to be automatically equivalent to their unaccented counterparts.</div>
<div class="clause" id="s16_p6_c6"><span class="label">s16_p6_c6</span>Where automatic equivalences are desired, this may be achieved through the use of programmatically generated CNAME records.</div>
<div class="clause" id="s16_p6_c7"><span class="label">s16_p6_c7</span>For example, if a responder has an address record for an accented name Y, and a querier issues a query for a name X, where X is the same as Y with all the accents removed, then the responder may issue a response containing two resource records: a CNAME record "X CNAME Y", asserting that the requested name X (unaccented) is an alias for the true (accented) name Y, followed by the address record for Y.</div>
</div>

<h2 id="s17">17 Multicast DNS Message Size</h2>

<a name="s17" /><div class="paragraph" id="s17_p1">
<div class="clause" id="s17_p1_c1"><span class="label">s17_p1_c1</span>The 1987 DNS specification [RFC1035] restricts DNS messages carried by UDP to no more than 512 bytes (not counting the IP or UDP headers).</div>
<div class="clause" id="s17_p1_c2"><span class="label">s17_p1_c2</span>For UDP packets carried over the wide-area Internet in 1987, this was appropriate.</div>
<div class="clause" id="s17_p1_c3"><span class="label">s17_p1_c3</span>For link-local multicast packets on today's networks, there is no reason to retain this restriction.</div>
<div class="clause" id="s17_p1_c4"><span class="label">s17_p1_c4</span>Given that the packets are by definition link-local, there are no Path MTU issues to consider.</div>
</div>

<div class="paragraph" id="s17_p2">
<div class="clause" id="s17_p2_c1"><span class="label">s17_p2_c1</span>Multicast DNS messages carried by UDP may be up to the IP MTU of the physical interface, less the space required for the IP header (20 bytes for IPv4; 40 bytes for IPv6) and the UDP header (8 bytes).</div>
</div>

<div class="paragraph" id="s17_p3">
<div class="clause should" id="s17_p3_c1"><span class="label">s17_p3_c1</span>In the case of a single Multicast DNS resource record that is too large to fit in a single MTU-sized multicast response packet, a Multicast DNS responder SHOULD send the resource record alone, in a single IP datagram, using multiple IP fragments.</div>
<div class="clause should" id="s17_p3_c2"><span class="label">s17_p3_c2</span>Resource records this large SHOULD be avoided, except in the very rare cases where they really are the appropriate solution to the problem at hand.</div>
<div class="clause should" id="s17_p3_c3"><span class="label">s17_p3_c3</span>Implementers should be aware that many simple devices do not reassemble fragmented IP datagrams, so large resource records SHOULD NOT be used except in specialized cases where the implementer knows that all receivers implement reassembly, or where the large resource record contains optional data which is not essential for correct operation of the client.</div>
</div>

<div class="paragraph" id="s17_p4">
<div class="clause must" id="s17_p4_c1"><span class="label">s17_p4_c1</span>A Multicast DNS packet larger than the interface MTU, which is sent using fragments, MUST NOT contain more than one resource record.</div>
</div>

<div class="paragraph" id="s17_p5">
<div class="clause must" id="s17_p5_c1"><span class="label">s17_p5_c1</span>Even when fragmentation is used, a Multicast DNS packet, including IP and UDP headers, MUST NOT exceed 9000 bytes.</div>
</div>

<div class="paragraph" id="s17_p6">
<div class="clause" id="s17_p6_c1"><span class="label">s17_p6_c1</span>Note that 9000 bytes is also the maximum payload size of an Ethernet "Jumbo" packet [Jumbo].</div>
<div class="clause" id="s17_p6_c2"><span class="label">s17_p6_c2</span>However, in practice Ethernet "Jumbo" packets are not widely used, so it is advantageous to keep packets under 1500 bytes whenever possible.</div>
<div class="clause" id="s17_p6_c3"><span class="label">s17_p6_c3</span>Even on hosts that normally handle Ethernet "Jumbo" packets and IP fragment reassembly, it is becoming more common for these hosts to implement power-saving modes where the main CPU goes to sleep and hands off packet reception tasks to a more limited processor in the network interface hardware, which may not support Ethernet "Jumbo" packets or IP fragment reassembly.</div>
</div>

<h2 id="s18">18 Multicast DNS Message Format</h2>

<a name="s18" /><div class="paragraph" id="s18_p1">
<div class="clause" id="s18_p1_c1"><span class="label">s18_p1_c1</span>This section describes specific rules pertaining to the allowable values for the header fields of a Multicast DNS message, and other message format considerations.</div>
</div>

<h2 id="s18.1">18.1 ID (Query Identifier)</h2>

<a name="s18.1" /><div class="paragraph" id="s18.1_p1">
<div class="clause should" id="s18.1_p1_c1"><span class="label">s18.1_p1_c1</span>Multicast DNS implementations SHOULD listen for unsolicited responses issued by hosts booting up (or waking up from sleep or otherwise joining the network).</div>
<div class="clause should" id="s18.1_p1_c2"><span class="label">s18.1_p1_c2</span>Since these unsolicited responses may contain a useful answer to a question for which the querier is currently awaiting an answer, Multicast DNS implementations SHOULD examine all received Multicast DNS response messages for useful answers, without regard to the contents of the ID field or the Question Section.</div>
<div class="clause" id="s18.1_p1_c3"><span class="label">s18.1_p1_c3</span>In Multicast DNS, knowing which particular query message (if any) is responsible for eliciting a particular response message is less interesting than knowing whether the response message contains useful information.</div>
</div>

<div class="paragraph" id="s18.1_p2">
<div class="clause may" id="s18.1_p2_c1"><span class="label">s18.1_p2_c1</span>Multicast DNS implementations MAY cache data from any or all Multicast DNS response messages they receive, for possible future use, provided of course that normal TTL aging is performed on these cached resource records.</div>
</div>

<div class="paragraph" id="s18.1_p3">
<div class="clause should" id="s18.1_p3_c1"><span class="label">s18.1_p3_c1</span>In multicast query messages, the Query Identifier SHOULD be set to zero on transmission.</div>
</div>

<div class="paragraph" id="s18.1_p4">
<div class="clause must" id="s18.1_p4_c1"><span class="label">s18.1_p4_c1</span>In multicast responses, including unsolicited multicast responses, the Query Identifier MUST be set to zero on transmission, and MUST be ignored on reception.</div>
</div>

<div class="paragraph" id="s18.1_p5">
<div class="clause must" id="s18.1_p5_c1"><span class="label">s18.1_p5_c1</span>In legacy unicast response messages generated specifically in response to a particular (unicast or multicast) query, the Query Identifier MUST match the ID from the query message.</div>
</div>

<h2 id="s18.2">18.2 QR (Query/Response) Bit</h2>

<a name="s18.2" /><div class="paragraph" id="s18.2_p1">
<div class="clause must" id="s18.2_p1_c1"><span class="label">s18.2_p1_c1</span>In query messages the QR bit MUST be zero.</div>
<div class="clause must" id="s18.2_p1_c2"><span class="label">s18.2_p1_c2</span>In response messages the QR bit MUST be one.</div>
</div>

<h2 id="s18.3">18.3 OPCODE</h2>

<a name="s18.3" /><div class="paragraph" id="s18.3_p1">
<div class="clause must" id="s18.3_p1_c1"><span class="label">s18.3_p1_c1</span>In both multicast query and multicast response messages, the OPCODE MUST be zero on transmission (only standard queries are currently supported over multicast).</div>
<div class="clause must" id="s18.3_p1_c2"><span class="label">s18.3_p1_c2</span>Multicast DNS messages received with an OPCODE other than zero MUST be silently ignored.</div>
</div>

<h2 id="s18.4">18.4 AA (Authoritative Answer) Bit</h2>

<a name="s18.4" /><div class="paragraph" id="s18.4_p1">
<div class="clause must" id="s18.4_p1_c1"><span class="label">s18.4_p1_c1</span>In query messages, the Authoritative Answer bit MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<div class="paragraph" id="s18.4_p2">
<div class="clause must" id="s18.4_p2_c1"><span class="label">s18.4_p2_c1</span>In response messages for Multicast domains, the Authoritative Answer bit MUST be set to one (not setting this bit would imply there's some other place where "better" information may be found) and MUST be ignored on reception.</div>
</div>

<h2 id="s18.5">18.5 TC (Truncated) Bit</h2>

<a name="s18.5" /><div class="paragraph" id="s18.5_p1">
<div class="clause" id="s18.5_p1_c1"><span class="label">s18.5_p1_c1</span>In query messages, if the TC bit is set, it means that additional Known-Answer records may be following shortly.</div>
<div class="clause should" id="s18.5_p1_c2"><span class="label">s18.5_p1_c2</span>A responder SHOULD record this fact, and wait for those additional Known-Answer records, before deciding whether to respond.</div>
<div class="clause" id="s18.5_p1_c3"><span class="label">s18.5_p1_c3</span>If the TC bit is clear, it means that the querying host has no additional Known Answers.</div>
</div>

<div class="paragraph" id="s18.5_p2">
<div class="clause must" id="s18.5_p2_c1"><span class="label">s18.5_p2_c1</span>In multicast response messages, the TC bit MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<div class="paragraph" id="s18.5_p3">
<div class="clause should" id="s18.5_p3_c1"><span class="label">s18.5_p3_c1</span>In legacy unicast response messages, the TC bit has the same meaning as in conventional Unicast DNS: it means that the response was too large to fit in a single packet, so the querier SHOULD reissue its query using TCP in order to receive the larger response.</div>
</div>

<h2 id="s18.6">18.6 RD (Recursion Desired) Bit</h2>

<a name="s18.6" /><div class="paragraph" id="s18.6_p1">
<div class="clause must" id="s18.6_p1_c1"><span class="label">s18.6_p1_c1</span>In both multicast query and multicast response messages, the Recursion Desired bit SHOULD be zero on transmission, and MUST be ignored on reception.</div>
</div>

<h2 id="s18.7">18.7 RA (Recursion Available) Bit</h2>

<a name="s18.7" /><div class="paragraph" id="s18.7_p1">
<div class="clause must" id="s18.7_p1_c1"><span class="label">s18.7_p1_c1</span>In both multicast query and multicast response messages, the Recursion Available bit MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<h2 id="s18.8">18.8 Z (Zero) Bit</h2>

<a name="s18.8" /><div class="paragraph" id="s18.8_p1">
<div class="clause must" id="s18.8_p1_c1"><span class="label">s18.8_p1_c1</span>In both query and response messages, the Zero bit MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<h2 id="s18.9">18.9 AD (Authentic Data) Bit</h2>

<a name="s18.9" /><div class="paragraph" id="s18.9_p1">
<div class="clause must" id="s18.9_p1_c1"><span class="label">s18.9_p1_c1</span>In both multicast query and multicast response messages, the Authentic Data bit [RFC2535] MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<h2 id="s18.10">18.10 CD (Checking Disabled) Bit</h2>

<a name="s18.10" /><div class="paragraph" id="s18.10_p1">
<div class="clause must" id="s18.10_p1_c1"><span class="label">s18.10_p1_c1</span>In both multicast query and multicast response messages, the Checking Disabled bit [RFC2535] MUST be zero on transmission, and MUST be ignored on reception.</div>
</div>

<h2 id="s18.11">18.11 RCODE (Response Code)</h2>

<a name="s18.11" /><div class="paragraph" id="s18.11_p1">
<div class="clause must" id="s18.11_p1_c1"><span class="label">s18.11_p1_c1</span>In both multicast query and multicast response messages, the Response Code MUST be zero on transmission.</div>
<div class="clause must" id="s18.11_p1_c2"><span class="label">s18.11_p1_c2</span>Multicast DNS messages received with non-zero Response Codes MUST be silently ignored.</div>
</div>

<h2 id="s18.12">18.12 Repurposing of Top Bit of qclass in Question Section</h2>

<a name="s18.12" /><div class="paragraph" id="s18.12_p1">
<div class="clause" id="s18.12_p1_c1"><span class="label">s18.12_p1_c1</span>In the Question Section of a Multicast DNS query, the top bit of the qclass field is used to indicate that unicast responses are preferred for this particular question.</div>
<div class="clause" id="s18.12_p1_c2"><span class="label">s18.12_p1_c2</span>(See Section 5.4.)</div>
</div>

<h2 id="s18.13">18.13 Repurposing of Top Bit of rrclass in Resource Record Sections</h2>

<a name="s18.13" /><div class="paragraph" id="s18.13_p1">
<div class="clause" id="s18.13_p1_c1"><span class="label">s18.13_p1_c1</span>In the Resource Record Sections of a Multicast DNS response, the top bit of the rrclass field is used to indicate that the record is a member of a unique RRSet, and the entire RRSet has been sent together (in the same packet, or in consecutive packets if there are too many records to fit in a single packet).</div>
<div class="clause" id="s18.13_p1_c2"><span class="label">s18.13_p1_c2</span>(See Section 10.2.)</div>
</div>

<h2 id="s18.14">18.14 Name Compression</h2>

<a name="s18.14" /><div class="paragraph" id="s18.14_p1">
<div class="clause should" id="s18.14_p1_c1"><span class="label">s18.14_p1_c1</span>When generating Multicast DNS messages, implementations SHOULD use name compression wherever possible to compress the names of resource records, by replacing some or all of the resource record name with a compact two-byte reference to an appearance of that data somewhere earlier in the message [RFC1035].</div>
</div>

<div class="paragraph" id="s18.14_p2">
<div class="clause" id="s18.14_p2_c1"><span class="label">s18.14_p2_c1</span>This applies not only to Multicast DNS responses, but also to queries.</div>
<div class="clause should" id="s18.14_p2_c2"><span class="label">s18.14_p2_c2</span>When a query contains more than one question, successive questions in the same message often contain similar names, and consequently name compression SHOULD be used, to save bytes.</div>
<div class="clause should" id="s18.14_p2_c3"><span class="label">s18.14_p2_c3</span>In addition, queries may also contain Known Answers in the Answer Section, or probe tiebreaking data in the Authority Section, and these names SHOULD similarly be compressed for network efficiency.</div>
</div>

<div class="paragraph" id="s18.14_p3">
<div class="clause should" id="s18.14_p3_c1"><span class="label">s18.14_p3_c1</span>In addition to compressing the *names* of resource records, names that appear within the *rdata* of the following rrtypes SHOULD also be compressed in all Multicast DNS messages:</div>
</div>

<div class="paragraph" id="s18.14_p4">
<div class="clause must" id="s18.14_p4_c1"><span class="label">s18.14_p4_c1</span>NS, CNAME, PTR, DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC Until future IETF Standards Action [RFC5226] specifying that names in the rdata of other types should be compressed, names that appear within the rdata of any type not listed above MUST NOT be compressed.</div>
</div>

<div class="paragraph" id="s18.14_p5">
<div class="clause must" id="s18.14_p5_c1"><span class="label">s18.14_p5_c1</span>Implementations receiving Multicast DNS messages MUST correctly decode compressed names appearing in the Question Section, and compressed names of resource records appearing in other sections.</div>
</div>

<div class="paragraph" id="s18.14_p6">
<div class="clause must" id="s18.14_p6_c1"><span class="label">s18.14_p6_c1</span>In addition, implementations MUST correctly decode compressed names appearing within the *rdata* of the rrtypes listed above.</div>
<div class="clause should" id="s18.14_p6_c2"><span class="label">s18.14_p6_c2</span>Where possible, implementations SHOULD also correctly decode compressed names appearing within the *rdata* of other rrtypes known to the implementers at the time of implementation, because such forward- thinking planning helps facilitate the deployment of future implementations that may have reason to compress those rrtypes.</div>
<div class="clause" id="s18.14_p6_c3"><span class="label">s18.14_p6_c3</span>It is possible that no future IETF Standards Action [RFC5226] will be created that mandates or permits the compression of rdata in new types, but having implementations designed such that they are capable of decompressing all known types helps keep future options open.</div>
</div>

<div class="paragraph" id="s18.14_p7">
<div class="clause" id="s18.14_p7_c1"><span class="label">s18.14_p7_c1</span>One specific difference between Unicast DNS and Multicast DNS is that Unicast DNS does not allow name compression for the target host in an SRV record, because Unicast DNS implementations before the first SRV specification in 1996 [RFC2052] may not decode these compressed records properly.</div>
<div class="clause must" id="s18.14_p7_c2"><span class="label">s18.14_p7_c2</span>Since all Multicast DNS implementations were created after 1996, all Multicast DNS implementations are REQUIRED to decode compressed SRV records correctly.</div>
</div>

<div class="paragraph" id="s18.14_p8">
<div class="clause must" id="s18.14_p8_c1"><span class="label">s18.14_p8_c1</span>In legacy unicast responses generated to answer legacy queries, name compression MUST NOT be performed on SRV records.</div>
</div>

<h2 id="s19">19 Summary of Differences between Multicast DNS and Unicast DNS</h2>

<a name="s19" /><div class="paragraph" id="s19_p1">
<div class="clause" id="s19_p1_c1"><span class="label">s19_p1_c1</span>Multicast DNS shares, as much as possible, the familiar APIs, naming syntax, resource record types, etc., of Unicast DNS.</div>
<div class="clause" id="s19_p1_c2"><span class="label">s19_p1_c2</span>There are, of course, necessary differences by virtue of it using multicast, and by virtue of it operating in a community of cooperating peers, rather than a precisely defined hierarchy controlled by a strict chain of formal delegations from the root.</div>
<div class="clause" id="s19_p1_c3"><span class="label">s19_p1_c3</span>These differences are summarized below:</div>
</div>

<div class="paragraph" id="s19_p2">
<div class="clause" id="s19_p2_c1"><span class="label">s19_p2_c1</span>Multicast DNS... * uses multicast * uses UDP port 5353 instead of port 53 * operates in well-defined parts of the DNS namespace * has no SOA (Start of Authority) records * uses UTF-8, and only UTF-8, to encode resource record names * allows names up to 255 bytes plus a terminating zero byte * allows name compression in rdata for SRV and other record types * allows larger UDP packets * allows more than one question in a query message * defines consistent results for qtype "ANY" and qclass "ANY" queries * uses the Answer Section of a query to list Known Answers * uses the TC bit in a query to indicate additional Known Answers * uses the Authority Section of a query for probe tiebreaking * ignores the Query ID field (except for generating legacy responses) * doesn't require the question to be repeated in the response message * uses unsolicited responses to announce new records * uses NSEC records to signal nonexistence of records * defines a unicast-response bit in the rrclass of query questions * defines a cache-flush bit in the rrclass of response records * uses DNS RR TTL 0 to indicate that a record has been deleted * recommends AAAA records in the additional section when responding to rrtype "A" queries, and vice versa * monitors queries to perform Duplicate Question Suppression * monitors responses to perform Duplicate Answer Suppression... * ... and Ongoing Conflict Detection * ... and Opportunistic Caching</div>
</div>

<h2 id="s20">20 IPv6 Considerations</h2>

<a name="s20" /><div class="paragraph" id="s20_p1">
<div class="clause" id="s20_p1_c1"><span class="label">s20_p1_c1</span>An IPv4-only host and an IPv6-only host behave as "ships that pass in the night".</div>
<div class="clause" id="s20_p1_c2"><span class="label">s20_p1_c2</span>Even if they are on the same Ethernet, neither is aware of the other's traffic.</div>
<div class="clause" id="s20_p1_c3"><span class="label">s20_p1_c3</span>For this reason, each physical link may have *two* unrelated ".local." zones, one for IPv4 and one for IPv6.</div>
<div class="clause" id="s20_p1_c4"><span class="label">s20_p1_c4</span>Since for practical purposes, a group of IPv4-only hosts and a group of IPv6-only hosts on the same Ethernet act as if they were on two entirely separate Ethernet segments, it is unsurprising that their use of the ".local." zone should occur exactly as it would if they really were on two entirely separate Ethernet segments.</div>
</div>

<div class="paragraph" id="s20_p2">
<div class="clause" id="s20_p2_c1"><span class="label">s20_p2_c1</span>A dual-stack (v4/v6) host can participate in both ".local." zones, and should register its name(s) and perform its lookups both using IPv4 and IPv6.</div>
<div class="clause" id="s20_p2_c2"><span class="label">s20_p2_c2</span>This enables it to reach, and be reached by, both IPv4-only and IPv6-only hosts.</div>
<div class="clause" id="s20_p2_c3"><span class="label">s20_p2_c3</span>In effect, this acts like a multihomed host, with one connection to the logical "IPv4 Ethernet segment", and a connection to the logical "IPv6 Ethernet segment".</div>
<div class="clause" id="s20_p2_c4"><span class="label">s20_p2_c4</span>When such a host generates NSEC records, if it is using the same host name for its IPv4 addresses and its IPv6 addresses on that network interface, its NSEC records should indicate that the host name has both A and AAAA records.</div>
</div>

<h2 id="s21">21 Security Considerations</h2>

<a name="s21" /><div class="paragraph" id="s21_p1">
<div class="clause" id="s21_p1_c1"><span class="label">s21_p1_c1</span>The algorithm for detecting and resolving name conflicts is, by its very nature, an algorithm that assumes cooperating participants.</div>
<div class="clause" id="s21_p1_c2"><span class="label">s21_p1_c2</span>Its purpose is to allow a group of hosts to arrive at a mutually disjoint set of host names and other DNS resource record names, in the absence of any central authority to coordinate this or mediate disputes.</div>
<div class="clause" id="s21_p1_c3"><span class="label">s21_p1_c3</span>In the absence of any higher authority to resolve disputes, the only alternative is that the participants must work together cooperatively to arrive at a resolution.</div>
</div>

<div class="paragraph" id="s21_p2">
<div class="clause" id="s21_p2_c1"><span class="label">s21_p2_c1</span>In an environment where the participants are mutually antagonistic and unwilling to cooperate, other mechanisms are appropriate, like manually configured DNS.</div>
</div>

<div class="paragraph" id="s21_p3">
<div class="clause" id="s21_p3_c1"><span class="label">s21_p3_c1</span>In an environment where there is a group of cooperating participants, but clients cannot be sure that there are no antagonistic hosts on the same physical link, the cooperating participants need to use IPsec signatures and/or DNSSEC [RFC4033] signatures so that they can distinguish Multicast DNS messages from trusted participants (which they process as usual) from Multicast DNS messages from untrusted participants (which they silently discard).</div>
</div>

<div class="paragraph" id="s21_p4">
<div class="clause" id="s21_p4_c1"><span class="label">s21_p4_c1</span>If DNS queries for *global* DNS names are sent to the mDNS multicast address (during network outages which disrupt communication with the greater Internet) it is *especially* important to use DNSSEC, because the user may have the impression that he or she is communicating with some authentic host, when in fact he or she is really communicating with some local host that is merely masquerading as that name.</div>
<div class="clause" id="s21_p4_c2"><span class="label">s21_p4_c2</span>This is less critical for names ending with ".local.", because the user should be aware that those names have only local significance and no global authority is implied.</div>
</div>

<div class="paragraph" id="s21_p5">
<div class="clause" id="s21_p5_c1"><span class="label">s21_p5_c1</span>Most computer users neglect to type the trailing dot at the end of a fully qualified domain name, making it a relative domain name (e.g., "www.example.com").</div>
<div class="clause" id="s21_p5_c2"><span class="label">s21_p5_c2</span>In the event of network outage, attempts to positively resolve the name as entered will fail, resulting in application of the search list, including ".local.", if present.</div>
<div class="clause" id="s21_p5_c3"><span class="label">s21_p5_c3</span>A malicious host could masquerade as "www.example.com." by answering the resulting Multicast DNS query for "www.example.com.local.".</div>
<div class="clause must" id="s21_p5_c4"><span class="label">s21_p5_c4</span>To avoid this, a host MUST NOT append the search suffix ".local.", if present, to any relative (partially qualified) host name containing two or more labels.</div>
<div class="clause" id="s21_p5_c5"><span class="label">s21_p5_c5</span>Appending ".local." to single-label relative host names is acceptable, since the user should have no expectation that a single-label host name will resolve as is.</div>
<div class="clause" id="s21_p5_c6"><span class="label">s21_p5_c6</span>However, users who have both "example.com" and "local" in their search lists should be aware that if they type "www" into their web browser, it may not be immediately clear to them whether the page that appears is "www.example.com" or "www.local".</div>
</div>

<div class="paragraph" id="s21_p6">
<div class="clause" id="s21_p6_c1"><span class="label">s21_p6_c1</span>Multicast DNS uses UDP port 5353.</div>
<div class="clause" id="s21_p6_c2"><span class="label">s21_p6_c2</span>On operating systems where only privileged processes are allowed to use ports below 1024, no such privilege is required to use port 5353.</div>
</div>

<h2 id="s22">22 IANA Considerations</h2>

<a name="s22" /><div class="paragraph" id="s22_p1">
<div class="clause" id="s22_p1_c1"><span class="label">s22_p1_c1</span>IANA has allocated the UDP port 5353 for the Multicast DNS protocol described in this document [SN].</div>
</div>

<div class="paragraph" id="s22_p2">
<div class="clause" id="s22_p2_c1"><span class="label">s22_p2_c1</span>IANA has allocated the IPv4 link-local multicast address 224.0.0.251 for the use described in this document [MC4].</div>
</div>

<div class="paragraph" id="s22_p3">
<div class="clause" id="s22_p3_c1"><span class="label">s22_p3_c1</span>IANA has allocated the IPv6 multicast address set FF0X::FB (where "X" indicates any hexadecimal digit from '1' to 'F') for the use described in this document [MC6].</div>
<div class="clause" id="s22_p3_c2"><span class="label">s22_p3_c2</span>Only address FF02::FB (link-local scope) is currently in use by deployed software, but it is possible that in the future implementers may experiment with Multicast DNS using larger-scoped addresses, such as FF05::FB (site-local scope) [RFC4291].</div>
</div>

<div class="paragraph" id="s22_p4">
<div class="clause" id="s22_p4_c1"><span class="label">s22_p4_c1</span>IANA has implemented the following DNS records:</div>
</div>

<div class="paragraph" id="s22_p5">
<div class="clause" id="s22_p5_c1"><span class="label">s22_p5_c1</span>MDNS.MCAST.NET.</div>
<div class="clause" id="s22_p5_c2"><span class="label">s22_p5_c2</span>IN  A    224.0.0.251 251.0.0.224.IN-ADDR.ARPA.</div>
<div class="clause" id="s22_p5_c3"><span class="label">s22_p5_c3</span>IN  PTR  MDNS.MCAST.NET.</div>
</div>

<div class="paragraph" id="s22_p6">
<div class="clause" id="s22_p6_c1"><span class="label">s22_p6_c1</span>Entries for the AAAA and corresponding PTR records have not been made as there is not yet an RFC providing direction for the management of the IP6.ARPA domain relating to the IPv6 multicast address space.</div>
</div>

<div class="paragraph" id="s22_p7">
<div class="clause" id="s22_p7_c1"><span class="label">s22_p7_c1</span>The reuse of the top bit of the rrclass field in the Question and Resource Record Sections means that Multicast DNS can only carry DNS records with classes in the range 0-32767.</div>
<div class="clause" id="s22_p7_c2"><span class="label">s22_p7_c2</span>Classes in the range 32768 to 65535 are incompatible with Multicast DNS.</div>
<div class="clause" id="s22_p7_c3"><span class="label">s22_p7_c3</span>IANA has noted this fact, and if IANA receives a request to allocate a DNS class value above 32767, IANA will make sure the requester is aware of this implication before proceeding.</div>
<div class="clause" id="s22_p7_c4"><span class="label">s22_p7_c4</span>This does not mean that allocations of DNS class values above 32767 should be denied, only that they should not be allowed until the requester has indicated that they are aware of how this allocation will interact with Multicast DNS.</div>
<div class="clause" id="s22_p7_c5"><span class="label">s22_p7_c5</span>However, to date, only three DNS classes have been assigned by IANA (1, 3, and 4), and only one (1, "Internet") is actually in widespread use, so this issue is likely to remain a purely theoretical one.</div>
</div>

<div class="paragraph" id="s22_p8">
<div class="clause" id="s22_p8_c1"><span class="label">s22_p8_c1</span>IANA has recorded the list of domains below as being Special-Use Domain Names [RFC6761]:</div>
</div>

<div class="paragraph" id="s22_p9">
<div class="clause" id="s22_p9_c1"><span class="label">s22_p9_c1</span>.local.</div>
<div class="clause" id="s22_p9_c2"><span class="label">s22_p9_c2</span>.254.169.in-addr.arpa.</div>
<div class="clause" id="s22_p9_c3"><span class="label">s22_p9_c3</span>.8.e.f.ip6.arpa.</div>
<div class="clause" id="s22_p9_c4"><span class="label">s22_p9_c4</span>.9.e.f.ip6.arpa.</div>
<div class="clause" id="s22_p9_c5"><span class="label">s22_p9_c5</span>.a.e.f.ip6.arpa.</div>
<div class="clause" id="s22_p9_c6"><span class="label">s22_p9_c6</span>.b.e.f.ip6.arpa.</div>
</div>

<h2 id="s22.1">22.1 Domain Name Reservation Considerations</h2>

<a name="s22.1" /><div class="paragraph" id="s22.1_p1">
<div class="clause" id="s22.1_p1_c1"><span class="label">s22.1_p1_c1</span>The six domains listed above, and any names falling within those domains (e.g., "MyPrinter.local.", "34.12.254.169.in-addr.arpa.", "Ink-Jet._pdl-datastream._tcp.local.") are special [RFC6761] in the following ways:</div>
</div>

<div class="paragraph" id="s22.1_p2">
<div class="clause" id="s22.1_p2_c1"><span class="label">s22.1_p2_c1</span>1. Users may use these names as they would other DNS names, entering them anywhere that they would otherwise enter a conventional DNS name, or a dotted decimal IPv4 address, or a literal IPv6 address.</div>
</div>

<div class="paragraph" id="s22.1_p3">
<div class="clause should" id="s22.1_p3_c1"><span class="label">s22.1_p3_c1</span>Since there is no central authority responsible for assigning dot-local names, and all devices on the local network are equally entitled to claim any dot-local name, users SHOULD be aware of this and SHOULD exercise appropriate caution.</div>
<div class="clause should" id="s22.1_p3_c2"><span class="label">s22.1_p3_c2</span>In an untrusted or unfamiliar network environment, users SHOULD be aware that using a name like "www.local" may not actually connect them to the web site they expected, and could easily connect them to a different web page, or even a fake or spoof of their intended web site, designed to trick them into revealing confidential information.</div>
<div class="clause" id="s22.1_p3_c3"><span class="label">s22.1_p3_c3</span>As always with networking, end-to-end cryptographic security can be a useful tool.</div>
<div class="clause" id="s22.1_p3_c4"><span class="label">s22.1_p3_c4</span>For example, when connecting with ssh, the ssh host key verification process will inform the user if it detects that the identity of the entity they are communicating with has changed since the last time they connected to that name.</div>
</div>

<div class="paragraph" id="s22.1_p4">
<div class="clause" id="s22.1_p4_c1"><span class="label">s22.1_p4_c1</span>2. Application software may use these names as they would other similar DNS names, and is not required to recognize the names and treat them specially.</div>
<div class="clause" id="s22.1_p4_c2"><span class="label">s22.1_p4_c2</span>Due to the relative ease of spoofing dot-local names, end-to-end cryptographic security remains important when communicating across a local network, just as it is when communicating across the global Internet.</div>
</div>

<div class="paragraph" id="s22.1_p5">
<div class="clause should" id="s22.1_p5_c1"><span class="label">s22.1_p5_c1</span>3. Name resolution APIs and libraries SHOULD recognize these names as special and SHOULD NOT send queries for these names to their configured (unicast) caching DNS server(s).</div>
<div class="clause" id="s22.1_p5_c2"><span class="label">s22.1_p5_c2</span>This is to avoid unnecessary load on the root name servers and other name servers, caused by queries for which those name servers do not have useful non-negative answers to give, and will not ever have useful non-negative answers to give.</div>
</div>

<div class="paragraph" id="s22.1_p6">
<div class="clause should" id="s22.1_p6_c1"><span class="label">s22.1_p6_c1</span>4. Caching DNS servers SHOULD recognize these names as special and SHOULD NOT attempt to look up NS records for them, or otherwise query authoritative DNS servers in an attempt to resolve these names.</div>
<div class="clause should" id="s22.1_p6_c2"><span class="label">s22.1_p6_c2</span>Instead, caching DNS servers SHOULD generate immediate NXDOMAIN responses for all such queries they may receive (from misbehaving name resolver libraries).</div>
<div class="clause" id="s22.1_p6_c3"><span class="label">s22.1_p6_c3</span>This is to avoid unnecessary load on the root name servers and other name servers.</div>
</div>

<div class="paragraph" id="s22.1_p7">
<div class="clause should" id="s22.1_p7_c1"><span class="label">s22.1_p7_c1</span>5. Authoritative DNS servers SHOULD NOT by default be configurable to answer queries for these names, and, like caching DNS servers, SHOULD generate immediate NXDOMAIN responses for all such queries they may receive.</div>
<div class="clause may" id="s22.1_p7_c2"><span class="label">s22.1_p7_c2</span>DNS server software MAY provide a configuration option to override this default, for testing purposes or other specialized uses.</div>
</div>

<div class="paragraph" id="s22.1_p8">
<div class="clause should" id="s22.1_p8_c1"><span class="label">s22.1_p8_c1</span>6. DNS server operators SHOULD NOT attempt to configure authoritative DNS servers to act as authoritative for any of these names.</div>
<div class="clause" id="s22.1_p8_c2"><span class="label">s22.1_p8_c2</span>Configuring an authoritative DNS server to act as authoritative for any of these names may not, in many cases, yield the expected result.</div>
<div class="clause should" id="s22.1_p8_c3"><span class="label">s22.1_p8_c3</span>Since name resolver libraries and caching DNS servers SHOULD NOT send queries for those names (see 3 and 4 above), such queries SHOULD be suppressed before they even reach the authoritative DNS server in question, and consequently it will not even get an opportunity to answer them.</div>
</div>

<div class="paragraph" id="s22.1_p9">
<div class="clause must" id="s22.1_p9_c1"><span class="label">s22.1_p9_c1</span>7. DNS Registrars MUST NOT allow any of these names to be registered in the normal way to any person or entity.</div>
<div class="clause" id="s22.1_p9_c2"><span class="label">s22.1_p9_c2</span>These names are reserved protocol identifiers with special meaning and fall outside the set of names available for allocation by registrars.</div>
<div class="clause" id="s22.1_p9_c3"><span class="label">s22.1_p9_c3</span>Attempting to allocate one of these names as if it were a normal domain name will probably not work as desired, for reasons 3, 4, and 6 above.</div>
</div>

<h2 id="s23">23 Acknowledgments</h2>

<a name="s23" /><div class="paragraph" id="s23_p1">
<div class="clause" id="s23_p1_c1"><span class="label">s23_p1_c1</span>The concepts described in this document have been explored, developed, and implemented with help from Ran Atkinson, Richard Brown, Freek Dijkstra, Erik Guttman, Kyle McKay, Pasi Sarolahti, Pekka Savola, Robby Simpson, Mark Townsley, Paul Vixie, Bill Woodcock, and others.</div>
<div class="clause" id="s23_p1_c2"><span class="label">s23_p1_c2</span>Special thanks go to Bob Bradley, Josh Graessley, Scott Herscher, Rory McGuire, Roger Pantos, and Kiren Sekar for their significant contributions.</div>
<div class="clause" id="s23_p1_c3"><span class="label">s23_p1_c3</span>Special thanks also to Kerry Lynn for converting the document to xml2rfc form in May 2010, and to Area Director Ralph Droms for shepherding the document through its final steps.</div>
</div>

<h2 id="s24">24 References</h2>

<a name="s24" /><h2 id="s24.1">24.1 Normative References</h2>

<a name="s24.1" /><div class="paragraph" id="s24.1_p1">
<div class="clause" id="s24.1_p1_c1"><span class="label">s24.1_p1_c1</span>[MC4]      IANA, "IPv4 Multicast Address Space Registry", &lt;http://www.iana.org/assignments/multicast-addresses/&gt;.</div>
</div>

<div class="paragraph" id="s24.1_p2">
<div class="clause" id="s24.1_p2_c1"><span class="label">s24.1_p2_c1</span>[MC6]      IANA, "IPv6 Multicast Address Space Registry", &lt;http://www.iana.org/assignments/ ipv6-multicast-addresses/&gt;.</div>
</div>

<div class="paragraph" id="s24.1_p3">
<div class="clause" id="s24.1_p3_c1"><span class="label">s24.1_p3_c1</span>[RFC0020]  Cerf, V., "ASCII format for network interchange", RFC 20, October 1969.</div>
</div>

<div class="paragraph" id="s24.1_p4">
<div class="clause" id="s24.1_p4_c1"><span class="label">s24.1_p4_c1</span>[RFC1034]  Mockapetris, P., "Domain names - concepts and facilities", STD 13, RFC 1034, November 1987.</div>
</div>

<div class="paragraph" id="s24.1_p5">
<div class="clause" id="s24.1_p5_c1"><span class="label">s24.1_p5_c1</span>[RFC1035]  Mockapetris, P., "Domain names - implementation and specification", STD 13, RFC 1035, November 1987.</div>
</div>

<div class="paragraph" id="s24.1_p6">
<div class="clause" id="s24.1_p6_c1"><span class="label">s24.1_p6_c1</span>[RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.</div>
</div>

<div class="paragraph" id="s24.1_p7">
<div class="clause" id="s24.1_p7_c1"><span class="label">s24.1_p7_c1</span>[RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO 10646", STD 63, RFC 3629, November 2003.</div>
</div>

<div class="paragraph" id="s24.1_p8">
<div class="clause" id="s24.1_p8_c1"><span class="label">s24.1_p8_c1</span>[RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, "Resource Records for the DNS Security Extensions", RFC 4034, March 2005.</div>
</div>

<div class="paragraph" id="s24.1_p9">
<div class="clause" id="s24.1_p9_c1"><span class="label">s24.1_p9_c1</span>[RFC5198]  Klensin, J. and M. Padlipsky, "Unicode Format for Network Interchange", RFC 5198, March 2008.</div>
</div>

<div class="paragraph" id="s24.1_p10">
<div class="clause" id="s24.1_p10_c1"><span class="label">s24.1_p10_c1</span>[RFC6195]  Eastlake 3rd, D., "Domain Name System (DNS) IANA Considerations", BCP 42, RFC 6195, March 2011.</div>
</div>

<div class="paragraph" id="s24.1_p11">
<div class="clause" id="s24.1_p11_c1"><span class="label">s24.1_p11_c1</span>[RFC6761]  Cheshire, S. and M. Krochmal, "Special-Use Domain Names", RFC 6761, February 2013.</div>
</div>

<div class="paragraph" id="s24.1_p12">
<div class="clause" id="s24.1_p12_c1"><span class="label">s24.1_p12_c1</span>[SN]       IANA, "Service Name and Transport Protocol Port Number Registry", &lt;http://www.iana.org/assignments/ service-names-port-numbers/&gt;.</div>
</div>

<h2 id="s24.2">24.2 Informative References</h2>

<a name="s24.2" /><div class="paragraph" id="s24.2_p1">
<div class="clause" id="s24.2_p1_c1"><span class="label">s24.2_p1_c1</span>[B4W]      "Bonjour for Windows", &lt;http://en.wikipedia.org/wiki/Bonjour_(software)&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p2">
<div class="clause" id="s24.2_p2_c1"><span class="label">s24.2_p2_c1</span>[BJ]       Apple Bonjour Open Source Software, &lt;http://developer.apple.com/bonjour/&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p3">
<div class="clause" id="s24.2_p3_c1"><span class="label">s24.2_p3_c1</span>[IEEE.802.3] "Information technology - Telecommunications and information exchange between systems - Local and metropolitan area networks - Specific requirements - Part 3: Carrier Sense Multiple Access with Collision Detection (CMSA/CD) Access Method and Physical Layer Specifications", IEEE Std 802.3-2008, December 2008, &lt;http://standards.ieee.org/getieee802/802.3.html&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p4">
<div class="clause" id="s24.2_p4_c1"><span class="label">s24.2_p4_c1</span>[IEEE.802.11] "Information technology - Telecommunications and information exchange between systems - Local and metropolitan area networks - Specific requirements - Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications", IEEE Std 802.11-2007, June 2007, &lt;http://standards.ieee.org/getieee802/802.11.html&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p5">
<div class="clause" id="s24.2_p5_c1"><span class="label">s24.2_p5_c1</span>[Jumbo]    "Ethernet Jumbo Frames", November 2009, &lt;http://www.ethernetalliance.org/library/whitepaper/ ethernet-jumbo-frames/&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p6">
<div class="clause" id="s24.2_p6_c1"><span class="label">s24.2_p6_c1</span>[NIAS]     Cheshire, S. "Discovering Named Instances of Abstract Services using DNS", Work in Progress, July 2001.</div>
</div>

<div class="paragraph" id="s24.2_p7">
<div class="clause" id="s24.2_p7_c1"><span class="label">s24.2_p7_c1</span>[NSD]      "NsdManager | Android Developer", June 2012, &lt;http://developer.android.com/reference/ android/net/nsd/NsdManager.html&gt;.</div>
</div>

<div class="paragraph" id="s24.2_p8">
<div class="clause" id="s24.2_p8_c1"><span class="label">s24.2_p8_c1</span>[RFC2052]  Gulbrandsen, A. and P. Vixie, "A DNS RR for specifying the location of services (DNS SRV)", RFC 2052, October 1996.</div>
</div>

<div class="paragraph" id="s24.2_p9">
<div class="clause" id="s24.2_p9_c1"><span class="label">s24.2_p9_c1</span>[RFC2132]  Alexander, S. and R. Droms, "DHCP Options and BOOTP Vendor Extensions", RFC 2132, March 1997.</div>
</div>

<div class="paragraph" id="s24.2_p10">
<div class="clause" id="s24.2_p10_c1"><span class="label">s24.2_p10_c1</span>[RFC2136]  Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound, "Dynamic Updates in the Domain Name System (DNS UPDATE)", RFC 2136, April 1997.</div>
</div>

<div class="paragraph" id="s24.2_p11">
<div class="clause" id="s24.2_p11_c1"><span class="label">s24.2_p11_c1</span>[RFC2181]  Elz, R. and R. Bush, "Clarifications to the DNS Specification", RFC 2181, July 1997.</div>
</div>

<div class="paragraph" id="s24.2_p12">
<div class="clause" id="s24.2_p12_c1"><span class="label">s24.2_p12_c1</span>[RFC2535]  Eastlake 3rd, D., "Domain Name System Security Extensions", RFC 2535, March 1999.</div>
</div>

<div class="paragraph" id="s24.2_p13">
<div class="clause" id="s24.2_p13_c1"><span class="label">s24.2_p13_c1</span>[RFC2671]  Vixie, P., "Extension Mechanisms for DNS (EDNS0)", RFC 2671, August 1999.</div>
</div>

<div class="paragraph" id="s24.2_p14">
<div class="clause" id="s24.2_p14_c1"><span class="label">s24.2_p14_c1</span>[RFC2845]  Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B. Wellington, "Secret Key Transaction Authentication for DNS (TSIG)", RFC 2845, May 2000.</div>
</div>

<div class="paragraph" id="s24.2_p15">
<div class="clause" id="s24.2_p15_c1"><span class="label">s24.2_p15_c1</span>[RFC2930]  Eastlake 3rd, D., "Secret Key Establishment for DNS (TKEY RR)", RFC 2930, September 2000.</div>
</div>

<div class="paragraph" id="s24.2_p16">
<div class="clause" id="s24.2_p16_c1"><span class="label">s24.2_p16_c1</span>[RFC2931]  Eastlake 3rd, D., "DNS Request and Transaction Signatures ( SIG(0)s )", RFC 2931, September 2000.</div>
</div>

<div class="paragraph" id="s24.2_p17">
<div class="clause" id="s24.2_p17_c1"><span class="label">s24.2_p17_c1</span>[RFC3007]  Wellington, B., "Secure Domain Name System (DNS) Dynamic Update", RFC 3007, November 2000.</div>
</div>

<div class="paragraph" id="s24.2_p18">
<div class="clause" id="s24.2_p18_c1"><span class="label">s24.2_p18_c1</span>[RFC3492]  Costello, A., "Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)", RFC 3492, March 2003.</div>
</div>

<div class="paragraph" id="s24.2_p19">
<div class="clause" id="s24.2_p19_c1"><span class="label">s24.2_p19_c1</span>[RFC3927]  Cheshire, S., Aboba, B., and E. Guttman, "Dynamic Configuration of IPv4 Link-Local Addresses", RFC 3927, May 2005.</div>
</div>

<div class="paragraph" id="s24.2_p20">
<div class="clause" id="s24.2_p20_c1"><span class="label">s24.2_p20_c1</span>[RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, "DNS Security Introduction and Requirements", RFC 4033, March 2005.</div>
</div>

<div class="paragraph" id="s24.2_p21">
<div class="clause" id="s24.2_p21_c1"><span class="label">s24.2_p21_c1</span>[RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing Architecture", RFC 4291, February 2006.</div>
</div>

<div class="paragraph" id="s24.2_p22">
<div class="clause" id="s24.2_p22_c1"><span class="label">s24.2_p22_c1</span>[RFC4795]  Aboba, B., Thaler, D., and L. Esibov, "Link-local Multicast Name Resolution (LLMNR)", RFC 4795, January 2007.</div>
</div>

<div class="paragraph" id="s24.2_p23">
<div class="clause" id="s24.2_p23_c1"><span class="label">s24.2_p23_c1</span>[RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman, "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861, September 2007.</div>
</div>

<div class="paragraph" id="s24.2_p24">
<div class="clause" id="s24.2_p24_c1"><span class="label">s24.2_p24_c1</span>[RFC4862]  Thomson, S., Narten, T., and T. Jinmei, "IPv6 Stateless Address Autoconfiguration", RFC 4862, September 2007.</div>
</div>

<div class="paragraph" id="s24.2_p25">
<div class="clause" id="s24.2_p25_c1"><span class="label">s24.2_p25_c1</span>[RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 5226, May 2008.</div>
</div>

<div class="paragraph" id="s24.2_p26">
<div class="clause" id="s24.2_p26_c1"><span class="label">s24.2_p26_c1</span>[RFC5890]  Klensin, J., "Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework", RFC 5890, August 2010.</div>
</div>

<div class="paragraph" id="s24.2_p27">
<div class="clause" id="s24.2_p27_c1"><span class="label">s24.2_p27_c1</span>[RFC6281]  Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang, "Understanding Apple's Back to My Mac (BTMM) Service", RFC 6281, June 2011.</div>
</div>

<div class="paragraph" id="s24.2_p28">
<div class="clause" id="s24.2_p28_c1"><span class="label">s24.2_p28_c1</span>[RFC6760]  Cheshire, S. and M. Krochmal, "Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)", RFC 6760, February 2013.</div>
</div>

<div class="paragraph" id="s24.2_p29">
<div class="clause" id="s24.2_p29_c1"><span class="label">s24.2_p29_c1</span>[RFC6763]  Cheshire, S. and M. Krochmal, "DNS-Based Service Discovery", RFC 6763, February 2013.</div>
</div>

<div class="paragraph" id="s24.2_p30">
<div class="clause" id="s24.2_p30_c1"><span class="label">s24.2_p30_c1</span>[Zeroconf] Cheshire, S. and D. Steinberg, "Zero Configuration Networking: The Definitive Guide", O'Reilly Media, Inc., ISBN 0-596-10100-7, December 2005.</div>
</div>

<h2 id="sAppA">AppA Design Rationale for Choice of UDP Port Number</h2>

<a name="sAppA" /><div class="paragraph" id="sAppA_p1">
<div class="clause" id="sAppA_p1_c1"><span class="label">sAppA_p1_c1</span>Arguments were made for and against using UDP port 53, the standard Unicast DNS port.</div>
<div class="clause" id="sAppA_p1_c2"><span class="label">sAppA_p1_c2</span>Some of the arguments are given below.</div>
<div class="clause" id="sAppA_p1_c3"><span class="label">sAppA_p1_c3</span>The arguments for using a different port were greater in number and more compelling, so that option was ultimately selected.</div>
<div class="clause" id="sAppA_p1_c4"><span class="label">sAppA_p1_c4</span>The UDP port "5353" was selected for its mnemonic similarity to "53".</div>
</div>

<div class="paragraph" id="sAppA_p2">
<div class="clause" id="sAppA_p2_c1"><span class="label">sAppA_p2_c1</span>Arguments for using UDP port 53:</div>
</div>

<div class="paragraph" id="sAppA_p3">
<div class="clause" id="sAppA_p3_c1"><span class="label">sAppA_p3_c1</span>* This is "just DNS", so it should be the same port.</div>
</div>

<div class="paragraph" id="sAppA_p4">
<div class="clause" id="sAppA_p4_c1"><span class="label">sAppA_p4_c1</span>* There is less work to be done updating old resolver libraries to do simple Multicast DNS queries.</div>
<div class="clause" id="sAppA_p4_c2"><span class="label">sAppA_p4_c2</span>Only the destination address need be changed.</div>
<div class="clause" id="sAppA_p4_c3"><span class="label">sAppA_p4_c3</span>In some cases, this can be achieved without any code changes, just by adding the address 224.0.0.251 to a configuration file.</div>
</div>

<div class="paragraph" id="sAppA_p5">
<div class="clause" id="sAppA_p5_c1"><span class="label">sAppA_p5_c1</span>Arguments for using a different port (UDP port 5353):</div>
</div>

<div class="paragraph" id="sAppA_p6">
<div class="clause" id="sAppA_p6_c1"><span class="label">sAppA_p6_c1</span>* This is not "just DNS".</div>
<div class="clause" id="sAppA_p6_c2"><span class="label">sAppA_p6_c2</span>This is a DNS-like protocol, but different.</div>
</div>

<div class="paragraph" id="sAppA_p7">
<div class="clause" id="sAppA_p7_c1"><span class="label">sAppA_p7_c1</span>* Changing resolver library code to use a different port number is not hard.</div>
<div class="clause" id="sAppA_p7_c2"><span class="label">sAppA_p7_c2</span>In some cases, this can be achieved without any code changes, just by adding the address 224.0.0.251:5353 to a configuration file.</div>
</div>

<div class="paragraph" id="sAppA_p8">
<div class="clause" id="sAppA_p8_c1"><span class="label">sAppA_p8_c1</span>* Using the same port number makes it hard to run a Multicast DNS responder and a conventional Unicast DNS server on the same machine.</div>
<div class="clause" id="sAppA_p8_c2"><span class="label">sAppA_p8_c2</span>If a conventional Unicast DNS server wishes to implement Multicast DNS as well, it can still do that, by opening two sockets.</div>
<div class="clause" id="sAppA_p8_c3"><span class="label">sAppA_p8_c3</span>Having two different port numbers allows this flexibility.</div>
</div>

<div class="paragraph" id="sAppA_p9">
<div class="clause" id="sAppA_p9_c1"><span class="label">sAppA_p9_c1</span>* Some VPN software hijacks all outgoing traffic to port 53 and redirects it to a special DNS server set up to serve those VPN clients while they are connected to the corporate network.</div>
<div class="clause" id="sAppA_p9_c2"><span class="label">sAppA_p9_c2</span>It is questionable whether this is the right thing to do, but it is common, and redirecting link-local multicast DNS packets to a remote server rarely produces any useful results.</div>
<div class="clause" id="sAppA_p9_c3"><span class="label">sAppA_p9_c3</span>It does mean, for example, that a user of such VPN software becomes unable to access their local network printer sitting on their desk right next to their computer.</div>
<div class="clause" id="sAppA_p9_c4"><span class="label">sAppA_p9_c4</span>Using a different UDP port helps avoid this particular problem.</div>
</div>

<div class="paragraph" id="sAppA_p10">
<div class="clause" id="sAppA_p10_c1"><span class="label">sAppA_p10_c1</span>* On many operating systems, unprivileged software may not send or receive packets on low-numbered ports.</div>
<div class="clause" id="sAppA_p10_c2"><span class="label">sAppA_p10_c2</span>This means that any software sending or receiving Multicast DNS packets on port 53 would have to run as "root", which is an undesirable security risk.</div>
<div class="clause" id="sAppA_p10_c3"><span class="label">sAppA_p10_c3</span>Using a higher-numbered UDP port avoids this restriction.</div>
</div>

<h2 id="sAppB">AppB Design Rationale for Not Using Hashed Multicast Addresses</h2>

<a name="sAppB" /><div class="paragraph" id="sAppB_p1">
<div class="clause" id="sAppB_p1_c1"><span class="label">sAppB_p1_c1</span>Some discovery protocols use a range of multicast addresses, and determine the address to be used by a hash function of the name being sought.</div>
<div class="clause" id="sAppB_p1_c2"><span class="label">sAppB_p1_c2</span>Queries are sent via multicast to the address as indicated by the hash function, and responses are returned to the querier via unicast.</div>
<div class="clause" id="sAppB_p1_c3"><span class="label">sAppB_p1_c3</span>Particularly in IPv6, where multicast addresses are extremely plentiful, this approach is frequently advocated.</div>
<div class="clause" id="sAppB_p1_c4"><span class="label">sAppB_p1_c4</span>For example, IPv6 Neighbor Discovery [RFC4861] sends Neighbor Solicitation messages to the "solicited-node multicast address", which is computed as a function of the solicited IPv6 address.</div>
</div>

<div class="paragraph" id="sAppB_p2">
<div class="clause" id="sAppB_p2_c1"><span class="label">sAppB_p2_c1</span>There are some disadvantages to using hashed multicast addresses like this in a service discovery protocol:</div>
</div>

<div class="paragraph" id="sAppB_p3">
<div class="clause" id="sAppB_p3_c1"><span class="label">sAppB_p3_c1</span>* When a host has a large number of records with different names, the host may have to join a large number of multicast groups.</div>
<div class="clause" id="sAppB_p3_c2"><span class="label">sAppB_p3_c2</span>Each time a host joins or leaves a multicast group, this results in Internet Group Management Protocol (IGMP) or Multicast Listener Discovery (MLD) traffic on the network announcing this fact.</div>
<div class="clause" id="sAppB_p3_c3"><span class="label">sAppB_p3_c3</span>Joining a large number of multicast groups can place undue burden on the Ethernet hardware, which typically supports a limited number of multicast addresses efficiently.</div>
<div class="clause" id="sAppB_p3_c4"><span class="label">sAppB_p3_c4</span>When this number is exceeded, the Ethernet hardware may have to resort to receiving all multicasts and passing them up to the host networking code for filtering in software, thereby defeating much of the point of using a multicast address range in the first place.</div>
<div class="clause" id="sAppB_p3_c5"><span class="label">sAppB_p3_c5</span>Finally, many IPv6 stacks have a fixed limit IPV6_MAX_MEMBERSHIPS, and the code simply fails with an error if a client attempts to exceed this limit.</div>
<div class="clause" id="sAppB_p3_c6"><span class="label">sAppB_p3_c6</span>Common values for IPV6_MAX_MEMBERSHIPS are 20 or 31.</div>
</div>

<div class="paragraph" id="sAppB_p4">
<div class="clause" id="sAppB_p4_c1"><span class="label">sAppB_p4_c1</span>* Multiple questions cannot be placed in one packet if they don't all hash to the same multicast address.</div>
</div>

<div class="paragraph" id="sAppB_p5">
<div class="clause" id="sAppB_p5_c1"><span class="label">sAppB_p5_c1</span>* Duplicate Question Suppression doesn't work if queriers are not seeing each other's queries.</div>
</div>

<div class="paragraph" id="sAppB_p6">
<div class="clause" id="sAppB_p6_c1"><span class="label">sAppB_p6_c1</span>* Duplicate Answer Suppression doesn't work if responders are not seeing each other's responses.</div>
</div>

<div class="paragraph" id="sAppB_p7">
<div class="clause" id="sAppB_p7_c1"><span class="label">sAppB_p7_c1</span>* Opportunistic Caching doesn't work.</div>
</div>

<div class="paragraph" id="sAppB_p8">
<div class="clause" id="sAppB_p8_c1"><span class="label">sAppB_p8_c1</span>* Ongoing Conflict Detection doesn't work.</div>
</div>

<h2 id="sAppC">AppC Design Rationale for Maximum Multicast DNS Name Length</h2>

<a name="sAppC" /><div class="paragraph" id="sAppC_p1">
<div class="clause" id="sAppC_p1_c1"><span class="label">sAppC_p1_c1</span>Multicast DNS names may be up to 255 bytes long (in the on-the-wire message format), not counting the terminating zero byte at the end.</div>
</div>

<div class="paragraph" id="sAppC_p2">
<div class="clause" id="sAppC_p2_c1"><span class="label">sAppC_p2_c1</span>"Domain Names - Implementation and Specification" [RFC1035] says:</div>
</div>

<div class="paragraph" id="sAppC_p3">
<div class="clause" id="sAppC_p3_c1"><span class="label">sAppC_p3_c1</span>Various objects and parameters in the DNS have size limits.</div>
<div class="clause" id="sAppC_p3_c2"><span class="label">sAppC_p3_c2</span>They are listed below.</div>
<div class="clause" id="sAppC_p3_c3"><span class="label">sAppC_p3_c3</span>Some could be easily changed, others are more fundamental.</div>
</div>

<div class="paragraph" id="sAppC_p4">
<div class="clause" id="sAppC_p4_c1"><span class="label">sAppC_p4_c1</span>labels          63 octets or less names           255 octets or less ...</div>
</div>

<div class="paragraph" id="sAppC_p5">
<div class="clause" id="sAppC_p5_c1"><span class="label">sAppC_p5_c1</span>the total length of a domain name (i.e., label octets and label length octets) is restricted to 255 octets or less.</div>
</div>

<div class="paragraph" id="sAppC_p6">
<div class="clause" id="sAppC_p6_c1"><span class="label">sAppC_p6_c1</span>This text does not state whether this 255-byte limit includes the terminating zero at the end of every name.</div>
</div>

<div class="paragraph" id="sAppC_p7">
<div class="clause" id="sAppC_p7_c1"><span class="label">sAppC_p7_c1</span>Several factors lead us to conclude that the 255-byte limit does *not* include the terminating zero:</div>
</div>

<div class="paragraph" id="sAppC_p8">
<div class="clause" id="sAppC_p8_c1"><span class="label">sAppC_p8_c1</span>o It is common in software engineering to have size limits that are a power of two, or a multiple of a power of two, for efficiency.</div>
<div class="clause" id="sAppC_p8_c2"><span class="label">sAppC_p8_c2</span>For example, an integer on a modern processor is typically 2, 4, or 8 bytes, not 3 or 5 bytes.</div>
<div class="clause" id="sAppC_p8_c3"><span class="label">sAppC_p8_c3</span>The number 255 is not a power of two, nor is it to most people a particularly noteworthy number.</div>
<div class="clause" id="sAppC_p8_c4"><span class="label">sAppC_p8_c4</span>It is noteworthy to computer scientists for only one reason -- because it is exactly one *less* than a power of two.</div>
<div class="clause" id="sAppC_p8_c5"><span class="label">sAppC_p8_c5</span>When a size limit is exactly one less than a power of two, that suggests strongly that the one extra byte is being reserved for some specific reason -- in this case reserved, perhaps, to leave room for a terminating zero at the end.</div>
</div>

<div class="paragraph" id="sAppC_p9">
<div class="clause" id="sAppC_p9_c1"><span class="label">sAppC_p9_c1</span>o In the case of DNS label lengths, the stated limit is 63 bytes.</div>
<div class="clause" id="sAppC_p9_c2"><span class="label">sAppC_p9_c2</span>As with the total name length, this limit is exactly one less than a power of two.</div>
<div class="clause" id="sAppC_p9_c3"><span class="label">sAppC_p9_c3</span>This label length limit also excludes the label length byte at the start of every label.</div>
<div class="clause" id="sAppC_p9_c4"><span class="label">sAppC_p9_c4</span>Including that extra byte, a 63-byte label takes 64 bytes of space in memory or in a DNS message.</div>
</div>

<div class="paragraph" id="sAppC_p10">
<div class="clause" id="sAppC_p10_c1"><span class="label">sAppC_p10_c1</span>o It is common in software engineering for the semantic "length" of an object to be one less than the number of bytes it takes to store that object.</div>
<div class="clause" id="sAppC_p10_c2"><span class="label">sAppC_p10_c2</span>For example, in C, strlen("foo") is 3, but sizeof("foo") (which includes the terminating zero byte at the end) is 4.</div>
</div>

<div class="paragraph" id="sAppC_p11">
<div class="clause" id="sAppC_p11_c1"><span class="label">sAppC_p11_c1</span>o The text describing the total length of a domain name mentions explicitly that label length and data octets are included, but does not mention the terminating zero at the end.</div>
<div class="clause" id="sAppC_p11_c2"><span class="label">sAppC_p11_c2</span>The zero byte at the end of a domain name is not a label length.</div>
<div class="clause" id="sAppC_p11_c3"><span class="label">sAppC_p11_c3</span>Indeed, the value zero is chosen as the terminating marker precisely because it is not a legal length byte value -- DNS prohibits empty labels.</div>
<div class="clause" id="sAppC_p11_c4"><span class="label">sAppC_p11_c4</span>For example, a name like "bad..name." is not a valid domain name because it contains a zero-length label in the middle, which cannot be expressed in a DNS message, because software parsing the message would misinterpret a zero label-length byte as being a zero "end of name" marker instead.</div>
</div>

<div class="paragraph" id="sAppC_p12">
<div class="clause" id="sAppC_p12_c1"><span class="label">sAppC_p12_c1</span>Finally, "Clarifications to the DNS Specification" [RFC2181] offers additional confirmation that, in the context of DNS specifications, the stated "length" of a domain name does not include the terminating zero byte at the end.</div>
<div class="clause" id="sAppC_p12_c2"><span class="label">sAppC_p12_c2</span>That document refers to the root name, which is typically written as "." and is represented in a DNS message by a single lone zero byte (i.e., zero bytes of data plus a terminating zero), as the "zero length full name":</div>
</div>

<div class="paragraph" id="sAppC_p13">
<div class="clause" id="sAppC_p13_c1"><span class="label">sAppC_p13_c1</span>The zero length full name is defined as representing the root of the DNS tree, and is typically written and displayed as ".".</div>
</div>

<div class="paragraph" id="sAppC_p14">
<div class="clause" id="sAppC_p14_c1"><span class="label">sAppC_p14_c1</span>This wording supports the interpretation that, in a DNS context, when talking about lengths of names, the terminating zero byte at the end is not counted.</div>
<div class="clause" id="sAppC_p14_c2"><span class="label">sAppC_p14_c2</span>If the root name (".") is considered to be zero length, then to be consistent, the length (for example) of "org" has to be 4 and the length of "ietf.org" has to be 9, as shown below:</div>
</div>

<div class="paragraph" id="sAppC_p15">
<div class="clause" id="sAppC_p15_c1"><span class="label">sAppC_p15_c1</span>------ | 0x00 |   length = 0 ------ ------------------   ------ | 0x03 | o | r | g | | 0x00 |   length = 4 ------------------   ------ -----------------------------------------   ------ | 0x04 | i | e | t | f | 0x03 | o | r | g | | 0x00 |   length = 9 -----------------------------------------   ------ This means that the maximum length of a domain name, as represented in a Multicast DNS message, up to but not including the final terminating zero, must not exceed 255 bytes.</div>
</div>

<div class="paragraph" id="sAppC_p16">
<div class="clause" id="sAppC_p16_c1"><span class="label">sAppC_p16_c1</span>However, many Unicast DNS implementers have read these RFCs differently, and argue that the 255-byte limit does include the terminating zero, and that the "Clarifications to the DNS Specification" [RFC2181] statement that "." is the "zero length full name" was simply a mistake.</div>
</div>

<div class="paragraph" id="sAppC_p17">
<div class="clause" id="sAppC_p17_c1"><span class="label">sAppC_p17_c1</span>Hence, implementers should be aware that other Unicast DNS implementations may limit the maximum domain name to 254 bytes plus a terminating zero, depending on how that implementer interpreted the DNS specifications.</div>
</div>

<div class="paragraph" id="sAppC_p18">
<div class="clause must" id="sAppC_p18_c1"><span class="label">sAppC_p18_c1</span>Compliant Multicast DNS implementations MUST support names up to 255 bytes plus a terminating zero, i.e., 256 bytes total.</div>
</div>

<h2 id="sAppD">AppD Benefits of Multicast Responses</h2>

<a name="sAppD" /><div class="paragraph" id="sAppD_p1">
<div class="clause" id="sAppD_p1_c1"><span class="label">sAppD_p1_c1</span>Some people have argued that sending responses via multicast is inefficient on the network.</div>
<div class="clause" id="sAppD_p1_c2"><span class="label">sAppD_p1_c2</span>In fact, using multicast responses can result in a net lowering of overall multicast traffic for a variety of reasons, and provides other benefits too:</div>
</div>

<div class="paragraph" id="sAppD_p2">
<div class="clause" id="sAppD_p2_c1"><span class="label">sAppD_p2_c1</span>* Opportunistic Caching.</div>
<div class="clause" id="sAppD_p2_c2"><span class="label">sAppD_p2_c2</span>One multicast response can update the caches on all machines on the network.</div>
<div class="clause" id="sAppD_p2_c3"><span class="label">sAppD_p2_c3</span>If another machine later wants to issue the same query, and it already has the answer in its cache, it may not need to even transmit that multicast query on the network at all.</div>
</div>

<div class="paragraph" id="sAppD_p3">
<div class="clause" id="sAppD_p3_c1"><span class="label">sAppD_p3_c1</span>* Duplicate Query Suppression.</div>
<div class="clause" id="sAppD_p3_c2"><span class="label">sAppD_p3_c2</span>When more than one machine has the same ongoing long-lived query running, every machine does not have to transmit its own independent query.</div>
<div class="clause" id="sAppD_p3_c3"><span class="label">sAppD_p3_c3</span>When one machine transmits a query, all the other hosts see the answers, so they can suppress their own queries.</div>
</div>

<div class="paragraph" id="sAppD_p4">
<div class="clause" id="sAppD_p4_c1"><span class="label">sAppD_p4_c1</span>* Passive Observation Of Failures (POOF).</div>
<div class="clause" id="sAppD_p4_c2"><span class="label">sAppD_p4_c2</span>When a host sees a multicast query, but does not see the corresponding multicast response, it can use this information to promptly delete stale data from its cache.</div>
<div class="clause" id="sAppD_p4_c3"><span class="label">sAppD_p4_c3</span>To achieve the same level of user-interface quality and responsiveness without multicast responses would require lower cache lifetimes and more frequent network polling, resulting in a higher packet rate.</div>
</div>

<div class="paragraph" id="sAppD_p5">
<div class="clause" id="sAppD_p5_c1"><span class="label">sAppD_p5_c1</span>* Passive Conflict Detection.</div>
<div class="clause" id="sAppD_p5_c2"><span class="label">sAppD_p5_c2</span>Just because a name has been previously verified to be unique does not guarantee it will continue to be so indefinitely.</div>
<div class="clause" id="sAppD_p5_c3"><span class="label">sAppD_p5_c3</span>By allowing all Multicast DNS responders to constantly monitor their peers' responses, conflicts arising out of network topology changes can be promptly detected and resolved.</div>
<div class="clause" id="sAppD_p5_c4"><span class="label">sAppD_p5_c4</span>If responses were not sent via multicast, some other conflict detection mechanism would be needed, imposing its own additional burden on the network.</div>
</div>

<div class="paragraph" id="sAppD_p6">
<div class="clause" id="sAppD_p6_c1"><span class="label">sAppD_p6_c1</span>* Use on devices with constrained memory resources: When using delayed responses to reduce network collisions, responders need to maintain a list recording to whom each answer should be sent.</div>
<div class="clause" id="sAppD_p6_c2"><span class="label">sAppD_p6_c2</span>The option of multicast responses allows responders with limited storage, which cannot store an arbitrarily long list of response addresses, to choose to fail-over to a single multicast response in place of multiple unicast responses, when appropriate.</div>
</div>

<div class="paragraph" id="sAppD_p7">
<div class="clause" id="sAppD_p7_c1"><span class="label">sAppD_p7_c1</span>* Overlayed Subnets.</div>
<div class="clause" id="sAppD_p7_c2"><span class="label">sAppD_p7_c2</span>In the case of overlayed subnets, multicast responses allow a receiver to know with certainty that a response originated on the local link, even when its source address may apparently suggest otherwise.</div>
</div>

<div class="paragraph" id="sAppD_p8">
<div class="clause" id="sAppD_p8_c1"><span class="label">sAppD_p8_c1</span>* Robustness in the face of misconfiguration: Link-local multicast transcends virtually every conceivable network misconfiguration.</div>
<div class="clause" id="sAppD_p8_c2"><span class="label">sAppD_p8_c2</span>Even if you have a collection of devices where every device's IP address, subnet mask, default gateway, and DNS server address are all wrong, packets sent by any of those devices addressed to a link-local multicast destination address will still be delivered to all peers on the local link.</div>
<div class="clause" id="sAppD_p8_c3"><span class="label">sAppD_p8_c3</span>This can be extremely helpful when diagnosing and rectifying network problems, since it facilitates a direct communication channel between client and server that works without reliance on ARP, IP routing tables, etc.</div>
<div class="clause" id="sAppD_p8_c4"><span class="label">sAppD_p8_c4</span>Being able to discover what IP address a device has (or thinks it has) is frequently a very valuable first step in diagnosing why it is unable to communicate on the local network.</div>
</div>

<h2 id="sAppE">AppE Design Rationale for Encoding Negative Responses</h2>

<a name="sAppE" /><div class="paragraph" id="sAppE_p1">
<div class="clause" id="sAppE_p1_c1"><span class="label">sAppE_p1_c1</span>Alternative methods of asserting nonexistence were considered, such as using an NXDOMAIN response, or emitting a resource record with zero-length rdata.</div>
</div>

<div class="paragraph" id="sAppE_p2">
<div class="clause" id="sAppE_p2_c1"><span class="label">sAppE_p2_c1</span>Using an NXDOMAIN response does not work well with Multicast DNS.</div>
<div class="clause" id="sAppE_p2_c2"><span class="label">sAppE_p2_c2</span>A Unicast DNS NXDOMAIN response applies to the entire message, but for efficiency Multicast DNS allows (and encourages) multiple responses in a single message.</div>
<div class="clause" id="sAppE_p2_c3"><span class="label">sAppE_p2_c3</span>If the error code in the header were NXDOMAIN, it would not be clear to which name(s) that error code applied.</div>
</div>

<div class="paragraph" id="sAppE_p3">
<div class="clause" id="sAppE_p3_c1"><span class="label">sAppE_p3_c1</span>Asserting nonexistence by emitting a resource record with zero-length rdata would mean that there would be no way to differentiate between a record that doesn't exist, and a record that does exist, with zero- length rdata.</div>
<div class="clause" id="sAppE_p3_c2"><span class="label">sAppE_p3_c2</span>By analogy, most file systems today allow empty files, so a file that exists with zero bytes of data is not considered equivalent to a filename that does not exist.</div>
</div>

<div class="paragraph" id="sAppE_p4">
<div class="clause" id="sAppE_p4_c1"><span class="label">sAppE_p4_c1</span>A benefit of asserting nonexistence through NSEC records instead of through NXDOMAIN responses is that NSEC records can be added to the Additional Section of a DNS response to offer additional information beyond what the querier explicitly requested.</div>
<div class="clause" id="sAppE_p4_c2"><span class="label">sAppE_p4_c2</span>For example, in response to an SRV query, a responder should include A record(s) giving its IPv4 addresses in the Additional Section, and an NSEC record indicating which other types it does or does not have for this name.</div>
<div class="clause" id="sAppE_p4_c3"><span class="label">sAppE_p4_c3</span>If the responder is running on a host that does not support IPv6 (or does support IPv6 but currently has no IPv6 address on that interface) then this NSEC record in the Additional Section will indicate this absence of AAAA records.</div>
<div class="clause" id="sAppE_p4_c4"><span class="label">sAppE_p4_c4</span>In effect, the responder is saying, "Here's my SRV record, and here are my IPv4 addresses, and no, I don't have any IPv6 addresses, so don't waste your time asking".</div>
<div class="clause" id="sAppE_p4_c5"><span class="label">sAppE_p4_c5</span>Without this information in the Additional Section, it would take the querier an additional round-trip to perform an additional query to ascertain that the target host has no AAAA records.</div>
<div class="clause" id="sAppE_p4_c6"><span class="label">sAppE_p4_c6</span>(Arguably Unicast DNS could also benefit from this ability to express nonexistence in the Additional Section, but that is outside the scope of this document.)</div>
</div>

<h2 id="sAppF">AppF Use of UTF-8</h2>

<a name="sAppF" /><div class="paragraph" id="sAppF_p1">
<div class="clause" id="sAppF_p1_c1"><span class="label">sAppF_p1_c1</span>After many years of debate, as a result of the perceived need to accommodate certain DNS implementations that apparently couldn't handle any character that's not a letter, digit, or hyphen (and apparently never would be updated to remedy this limitation), the Unicast DNS community settled on an extremely baroque encoding called "Punycode" [RFC3492].</div>
<div class="clause" id="sAppF_p1_c2"><span class="label">sAppF_p1_c2</span>Punycode is a remarkably ingenious encoding solution, but it is complicated, hard to understand, and hard to implement, using sophisticated techniques including insertion unsort coding, generalized variable-length integers, and bias adaptation.</div>
<div class="clause" id="sAppF_p1_c3"><span class="label">sAppF_p1_c3</span>The resulting encoding is remarkably compact given the constraints, but it's still not as good as simple straightforward UTF-8, and it's hard even to predict whether a given input string will encode to a Punycode string that fits within DNS's 63-byte limit, except by simply trying the encoding and seeing whether it fits.</div>
<div class="clause" id="sAppF_p1_c4"><span class="label">sAppF_p1_c4</span>Indeed, the encoded size depends not only on the input characters, but on the order they appear, so the same set of characters may or may not encode to a legal Punycode string that fits within DNS's 63-byte limit, depending on the order the characters appear.</div>
<div class="clause" id="sAppF_p1_c5"><span class="label">sAppF_p1_c5</span>This is extremely hard to present in a user interface that explains to users why one name is allowed, but another name containing the exact same characters is not.</div>
<div class="clause" id="sAppF_p1_c6"><span class="label">sAppF_p1_c6</span>Neither Punycode nor any other of the "ASCII- Compatible Encodings" [RFC5890] proposed for Unicast DNS may be used in Multicast DNS messages.</div>
<div class="clause" id="sAppF_p1_c7"><span class="label">sAppF_p1_c7</span>Any text being represented internally in some other representation must be converted to canonical precomposed UTF-8 before being placed in any Multicast DNS message.</div>
</div>

<h2 id="sAppG">AppG Private DNS Namespaces</h2>

<a name="sAppG" /><div class="paragraph" id="sAppG_p1">
<div class="clause" id="sAppG_p1_c1"><span class="label">sAppG_p1_c1</span>The special treatment of names ending in ".local." has been implemented in Macintosh computers since the days of Mac OS 9, and continues today in Mac OS X and iOS.</div>
<div class="clause" id="sAppG_p1_c2"><span class="label">sAppG_p1_c2</span>There are also implementations for Microsoft Windows [B4W], Linux, and other platforms.</div>
</div>

<div class="paragraph" id="sAppG_p2">
<div class="clause" id="sAppG_p2_c1"><span class="label">sAppG_p2_c1</span>Some network operators setting up private internal networks ("intranets") have used unregistered top-level domains, and some may have used the ".local" top-level domain.</div>
<div class="clause" id="sAppG_p2_c2"><span class="label">sAppG_p2_c2</span>Using ".local" as a private top-level domain conflicts with Multicast DNS and may cause problems for users.</div>
<div class="clause" id="sAppG_p2_c3"><span class="label">sAppG_p2_c3</span>Clients can be configured to send both Multicast and Unicast DNS queries in parallel for these names, and this does allow names to be looked up both ways, but this results in additional network traffic and additional delays in name resolution, as well as potentially creating user confusion when it is not clear whether any given result was received via link-local multicast from a peer on the same link, or from the configured unicast name server.</div>
<div class="clause" id="sAppG_p2_c4"><span class="label">sAppG_p2_c4</span>Because of this, we recommend against using ".local" as a private Unicast DNS top-level domain.</div>
<div class="clause" id="sAppG_p2_c5"><span class="label">sAppG_p2_c5</span>We do not recommend use of unregistered top-level domains at all, but should network operators decide to do this, the following top-level domains have been used on private internal networks without the problems caused by trying to reuse ".local." for this purpose:</div>
</div>

<div class="paragraph" id="sAppG_p3">
<div class="clause" id="sAppG_p3_c1"><span class="label">sAppG_p3_c1</span>.intranet.</div>
<div class="clause" id="sAppG_p3_c2"><span class="label">sAppG_p3_c2</span>.internal.</div>
<div class="clause" id="sAppG_p3_c3"><span class="label">sAppG_p3_c3</span>.private.</div>
<div class="clause" id="sAppG_p3_c4"><span class="label">sAppG_p3_c4</span>.corp.</div>
<div class="clause" id="sAppG_p3_c5"><span class="label">sAppG_p3_c5</span>.home.</div>
<div class="clause" id="sAppG_p3_c6"><span class="label">sAppG_p3_c6</span>.lan.</div>
</div>

<h2 id="sAppH">AppH Deployment History</h2>

<a name="sAppH" /><div class="paragraph" id="sAppH_p1">
<div class="clause" id="sAppH_p1_c1"><span class="label">sAppH_p1_c1</span>In July 1997, in an email to the net-thinkers@thumper.vmeng.com mailing list, Stuart Cheshire first proposed the idea of running the AppleTalk Name Binding Protocol [RFC6760] over IP.</div>
<div class="clause" id="sAppH_p1_c2"><span class="label">sAppH_p1_c2</span>As a result of this and related IETF discussions, the IETF Zeroconf working group was chartered September 1999.</div>
<div class="clause" id="sAppH_p1_c3"><span class="label">sAppH_p1_c3</span>After various working group discussions and other informal IETF discussions, several Internet- Drafts were written that were loosely related to the general themes of DNS and multicast, but did not address the service discovery aspect of NBP.</div>
</div>

<div class="paragraph" id="sAppH_p2">
<div class="clause" id="sAppH_p2_c1"><span class="label">sAppH_p2_c1</span>In April 2000, Stuart Cheshire registered IPv4 multicast address 224.0.0.251 with IANA [MC4] and began writing code to test and develop the idea of performing NBP-like service discovery using Multicast DNS, which was documented in a group of three Internet- Drafts:</div>
</div>

<div class="paragraph" id="sAppH_p3">
<div class="clause" id="sAppH_p3_c1"><span class="label">sAppH_p3_c1</span>o "Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)" [RFC6760] is an overview explaining the AppleTalk Name Binding Protocol, because many in the IETF community had little first-hand experience using AppleTalk, and confusion in the IETF community about what AppleTalk NBP did was causing confusion about what would be required in an IP-based replacement.</div>
</div>

<div class="paragraph" id="sAppH_p4">
<div class="clause" id="sAppH_p4_c1"><span class="label">sAppH_p4_c1</span>o "Discovering Named Instances of Abstract Services using DNS" [NIAS] proposed a way to perform NBP-like service discovery using DNS- compatible names and record types.</div>
</div>

<div class="paragraph" id="sAppH_p5">
<div class="clause" id="sAppH_p5_c1"><span class="label">sAppH_p5_c1</span>o "Multicast DNS" (this document) specifies a way to transport those DNS-compatible queries and responses using IP multicast, for zero- configuration environments where no conventional Unicast DNS server was available.</div>
</div>

<div class="paragraph" id="sAppH_p6">
<div class="clause" id="sAppH_p6_c1"><span class="label">sAppH_p6_c1</span>In 2001, an update to Mac OS 9 added resolver library support for host name lookup using Multicast DNS.</div>
<div class="clause" id="sAppH_p6_c2"><span class="label">sAppH_p6_c2</span>If the user typed a name such as "MyPrinter.local." into any piece of networking software that used the standard Mac OS 9 name lookup APIs, then those name lookup APIs would recognize the name as a dot-local name and query for it by sending simple one-shot Multicast DNS queries to 224.0.0.251:5353.</div>
<div class="clause" id="sAppH_p6_c3"><span class="label">sAppH_p6_c3</span>This enabled the user to, for example, enter the name "MyPrinter.local." into their web browser in order to view a printer's status and configuration web page, or enter the name "MyPrinter.local." into the printer setup utility to create a print queue for printing documents on that printer.</div>
</div>

<div class="paragraph" id="sAppH_p7">
<div class="clause" id="sAppH_p7_c1"><span class="label">sAppH_p7_c1</span>Multicast DNS responder software, with full service discovery, first began shipping to end users in volume with the launch of Mac OS X 10.2 "Jaguar" in August 2002, and network printer makers (who had historically supported AppleTalk in their network printers and were receptive to IP-based technologies that could offer them similar ease-of-use) started adopting Multicast DNS shortly thereafter.</div>
</div>

<div class="paragraph" id="sAppH_p8">
<div class="clause" id="sAppH_p8_c1"><span class="label">sAppH_p8_c1</span>In September 2002, Apple released the source code for the mDNSResponder daemon as Open Source under Apple's standard Apple Public Source License (APSL).</div>
</div>

<div class="paragraph" id="sAppH_p9">
<div class="clause" id="sAppH_p9_c1"><span class="label">sAppH_p9_c1</span>Multicast DNS responder software became available for Microsoft Windows users in June 2004 with the launch of Apple's "Rendezvous for Windows" (now "Bonjour for Windows"), both in executable form (a downloadable installer for end users) and as Open Source (one of the supported platforms within Apple's body of cross-platform code in the publicly accessible mDNSResponder CVS source code repository) [BJ].</div>
</div>

<div class="paragraph" id="sAppH_p10">
<div class="clause" id="sAppH_p10_c1"><span class="label">sAppH_p10_c1</span>In August 2006, Apple re-licensed the cross-platform mDNSResponder source code under the Apache License, Version 2.0.</div>
</div>

<div class="paragraph" id="sAppH_p11">
<div class="clause" id="sAppH_p11_c1"><span class="label">sAppH_p11_c1</span>In addition to desktop and laptop computers running Mac OS X and Microsoft Windows, Multicast DNS is now implemented in a wide range of hardware devices, such as Apple's "AirPort" wireless base stations, iPhone and iPad, and in home gateways from other vendors, network printers, network cameras, TiVo DVRs, etc.</div>
</div>

<div class="paragraph" id="sAppH_p12">
<div class="clause" id="sAppH_p12_c1"><span class="label">sAppH_p12_c1</span>The Open Source community has produced many independent implementations of Multicast DNS, some in C like Apple's mDNSResponder daemon, and others in a variety of different languages including Java, Python, Perl, and C#/Mono.</div>
</div>

<div class="paragraph" id="sAppH_p13">
<div class="clause" id="sAppH_p13_c1"><span class="label">sAppH_p13_c1</span>In January 2007, the IETF published the Informational RFC "Link-Local Multicast Name Resolution (LLMNR)" [RFC4795], which is substantially similar to Multicast DNS, but incompatible in some small but important ways.</div>
<div class="clause" id="sAppH_p13_c2"><span class="label">sAppH_p13_c2</span>In particular, the LLMNR design explicitly excluded support for service discovery, which made it an unsuitable candidate for a protocol to replace AppleTalk NBP [RFC6760].</div>
</div>

<div class="paragraph" id="sAppH_p14">
<div class="clause" id="sAppH_p14_c1"><span class="label">sAppH_p14_c1</span>While the original focus of Multicast DNS and DNS-Based Service Discovery was for zero-configuration environments without a conventional Unicast DNS server, DNS-Based Service Discovery also works using Unicast DNS servers, using DNS Update [RFC2136] [RFC3007] to create service discovery records and standard DNS queries to query for them.</div>
<div class="clause" id="sAppH_p14_c2"><span class="label">sAppH_p14_c2</span>Apple's Back to My Mac service, launched with Mac OS X 10.5 "Leopard" in October 2007, uses DNS-Based Service Discovery over Unicast DNS [RFC6281].</div>
</div>

<div class="paragraph" id="sAppH_p15">
<div class="clause" id="sAppH_p15_c1"><span class="label">sAppH_p15_c1</span>In June 2012, Google's Android operating system added native support for DNS-SD and Multicast DNS with the android.net.nsd.NsdManager class in Android 4.1 "Jelly Bean" (API Level 16) [NSD].</div>
</div>

<h2>Authors' Addresses</h2>

<div class="paragraph">
<span class="line" id="L3873">   Stuart Cheshire</span>
<span class="line" id="L3874">   Apple Inc.</span>
<span class="line" id="L3875">   1 Infinite Loop</span>
<span class="line" id="L3876">   Cupertino, CA  95014</span>
<span class="line" id="L3877">   USA</span>
<span class="line" id="L3879">   Phone: +1 408 974 3207</span>
<span class="line" id="L3880">   EMail: cheshire@apple.com</span>
<span class="line" id="L3883">   Marc Krochmal</span>
<span class="line" id="L3884">   Apple Inc.</span>
<span class="line" id="L3885">   1 Infinite Loop</span>
<span class="line" id="L3886">   Cupertino, CA  95014</span>
<span class="line" id="L3887">   USA</span>
<span class="line" id="L3889">   Phone: +1 408 974 4368</span>
<span class="line" id="L3890">   EMail: marc@apple.com</span>
</div>

</body>
</html>